###################
#  CFG file info  #
###################

CFG_VERSION="3"


########################
#  Input verification  #
########################

errortrack=0

# Translate user input to all lower case to prevent ID10T errors
translateToLowerCase()
{
	local lowercase=""
	lowercase="$(echo $1 | tr '[:upper:]' '[:lower:]')"
	echo "$lowercase"
}

# Function to track ID10T errors
derpDerp()
{
	if [ "$errortrack" -lt 12 ]; then
		errortrack=$((errortrack+1))
	fi

    derptext=""

	case $errortrack in
		1 ) derptext="Need some coffee?\n";;
		2 ) derptext="You should get some coffee.\n";;
		3 ) derptext="You are paying attention, right?\n";;
		4 ) derptext="All your typos are belong to us.\n";;
		5 ) derptext="We're sorry, your fingers are too fat.\n\nIf you would like to obtain a typing wand,\nplease mash your hand on the keyboard now.\n";;
		6 ) derptext="You have got to be kidding me...\n";;
		7 ) derptext="You're doing this intentionally, aren't you?\n";;
		8 ) derptext="Please step away from the keyboard, and back away slowly.\n";;
		9 ) derptext="You're making me angry. You wouldn't like me when I'm angry.\n";;
		10 ) derptext="How did you even get to this point?!?!?!?!\n";;
		11 ) derptext="Seriously, just give it up.\n";;
        * ) derptext="\*sigh\* Why are you still here?\n";;
	esac

    if [ "$errortrack" -lt 6 ]; then
        echo " "
        echo -e "${GREEN}${derptext}${NC}"
        echo -ne "${GREEN}Press any key to try again:${NC} "
        read anykey
        echo " "
    elif [ "$errortrack" -ge 6 ] && [ "$errortrack" -lt 10 ]; then
        echo " "
        echo -e "${YELLOW}${derptext}${NC}"
        echo -ne "${YELLOW}This really isn't that difficult. Press any key to try again:${NC} "
        read anykey
        echo " "
    elif [ "$errortrack" -ge 10 ]; then
        echo " "
        echo -e "${RED}${derptext}${NC}"
        echo -ne "${RED}The instructions are literally right there. Press any key to try again:${NC} "
        read anykey
        echo " "
    fi
	return
}

######################################################################################
#  Misc Functions, must be before any functions except input verification functions  #
######################################################################################

# Set bash text colors
setColors()
{
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    RED='\033[0;31m'
    NC='\033[0m'
}

# Not defined
cls()
{
  printf "\033c"
}

# Purty install text
print_green()
{
  printf >&2 "${GREEN}%0.s-${NC}" {1..80}
  printf >&2 "\n"
  printf >&2 "${GREEN}${1}${NC}\n"
  printf >&2 "${GREEN}%0.s-${NC}" {1..80}
  printf >&2 "\n"
}

# Check for new script version
checkScriptVer()
{
    TMP_FILE=$(mktemp -p "" "rmminstall_XXXXXXXXXX")
    curl -s -L "$2" > ${TMP_FILE}
    NEW_VER=$(grep "^SCRIPT_VERSION" "$TMP_FILE" | awk -F'[="]' '{print $3}')

    if [ "$1" -ne "${NEW_VER}" ]; then
        printf >&2 "${YELLOW}Old $3 detected, downloading and replacing with the latest version...${NC}\n"
        wget -q "$2" -O $3
        printf >&2 "${YELLOW}Script updated! Please re-run .$3${NC}\n"
        rm -f $TMP_FILE
        exit 1
    fi

    rm -f $TMP_FILE
}

# Check for functions updates
checkCfgVer()
{
    TMP_FILE=$(mktemp -p "" "rmminstall_XXXXXXXXXX")
    curl -s -L "$1" > ${TMP_FILE}
    NEW_VER=$(grep "^CFG_VERSION" "$TMP_FILE" | awk -F'[="]' '{print $3}')

    if [ "$CFG_VERSION" -ne "${NEW_VER}" ]; then
        printf >&2 "${YELLOW}Old bash function file detected, downloading and replacing with the latest version...${NC}\n"
        wget -q "$1" -O bashfunctions.cfg
        printf >&2 "${YELLOW}File updated! Please re-run .$2${NC}\n"
        rm -f $TMP_FILE
        exit 1
    fi

    rm -f $TMP_FILE
}

# Check for root as user
checkRoot()
{
    if [ $EUID -eq 0 ]; then
        echo -e "${RED}Do NOT run this script as root. Exiting.${NC}"
        exit 1
    fi
}

# Clone primary repo
clonePrimaryRepo()
{
    if [ "$1" == "install" ]; then
        sudo mkdir /rmm
        sudo chown ${USER}:${USER} /rmm
        sudo mkdir -p /var/log/celery
        sudo chown ${USER}:${USER} /var/log/celery
        git clone "$2" /rmm/
    fi
    cd /rmm
    git config user.email "admin@example.com"
    git config user.name "Bob"
    if [ "$1" == "install" ]; then
        git checkout "$3"
    elif [ "$1" == "update" ]; then
        git fetch
        git checkout "$3"
        git reset --hard FETCH_HEAD
        git clean -df
        git pull
    fi
}

# Clone scripts repo
cloneScriptsRepo()
{
    if [[ ! -d ${SCRIPTS_DIR} ]]; then
        sudo mkdir -p ${SCRIPTS_DIR}
        sudo chown ${USER}:${USER} ${SCRIPTS_DIR}
        git clone "$2" ${SCRIPTS_DIR}/
    fi    
    cd ${SCRIPTS_DIR}
    git config user.email "admin@example.com"
    git config user.name "Bob"
    if [ "$1" == "install" ]; then
        git checkout main
    elif [ "$1" == "update" ]; then
        git fetch
        git checkout main
        git reset --hard FETCH_HEAD
        git clean -df
        git pull
    fi
}

# Set primary repos to use
decideMainRepos()
{
    userconfirm="n"
    local own=""
    local bran=""
    
    until [ "$userconfirm" == "y" ]; do
        echo " "
        echo -ne "${YELLOW}Enter the dev repo owner name. This is right after github.com in the URL ${NC}: "
        read own
        own="$(translateToLowerCase $own)"
        echo " "
        echo -ne "${YELLOW}Is this correct? y or n${NC}: $own "
        read userconfirm
        userconfirm="$(translateToLowerCase $userconfirm)"
        if [ "$userconfirm" != "y" ]; then
            derpDerp;
        else
            echo -e "${YELLOW}Confirmed${NC}"
        fi
    done
    userconfirm="n"
    REPO_OWNER="$own"

    until [ "$userconfirm" == "y" ]; do
        echo " "
        echo -ne "${YELLOW}Enter the dev repo branch name. This is right after tacticalrmm in the URL ${NC}: "
        read bran
        bran="$(translateToLowerCase $bran)"
        echo " "
        echo -ne "${YELLOW}Is this correct? y or n${NC}: $bran "
        read userconfirm
        userconfirm="$(translateToLowerCase $userconfirm)"
        if [ "$userconfirm" != "y" ]; then
            derpDerp;
        else
            echo -e "${YELLOW}Confirmed${NC}"
        fi
    done
    userconfirm="n"
    BRANCH="$bran"

    ### Check for new functions version, only include script name as variable
    checkCfgVer  "$CFG_URL" "$THIS_SCRIPT";
    ### Check for new script version, pass script version, url, and script name variables in that order
    checkScriptVer "$SCRIPT_VERSION" "$SCRIPT_URL" "$THIS_SCRIPT";
}


###########################
#  System info functions  #
###########################

# Gather OS info
getOSInfo()
{
    osname=$(lsb_release -si); osname=${osname^}
    osname=$(echo "$osname" | tr  '[A-Z]' '[a-z]')
    fullrel=$(lsb_release -sd)
    codename=$(lsb_release -sc)
    relno=$(lsb_release -sr | cut -d. -f1)
    fullrelno=$(lsb_release -sr)
}

# Check OS if not recognised
wutOSThis()
{
    if [ ! "$osname" = "ubuntu" ] && [ ! "$osname" = "debian" ]; then
        osname=$(grep -oP '(?<=^ID=).+' /etc/os-release | tr -d '"')
        osname=${osname^}
    fi
}

# Verify Debian or Ubuntu and version
verifySupportedOS()
{
    if ([ "$osname" = "ubuntu" ] && ([ "$fullrelno" = "20.04" ] || [ "$fullrelno" = "22.04" ])) || ([ "$osname" = "debian" ] && [ $relno -ge 10 ]); then
        echo $fullrel
    else
        echo $fullrel
        echo -e "${RED}Supported versions: Ubuntu 20.04 and 22.04, Debian 10 and 11.${NC}"
        echo -e "${RED}Your system does not appear to be supported.${NC}"
        exit 1
    fi
}

# Check language/locale
checkLocale()
{
    if [[ "$LANG" != *".UTF-8" ]]; then
        printf >&2 "\n${RED}System locale must be ${GREEN}<some language>.UTF-8${RED} not ${YELLOW}${LANG}${NC}\n"
        printf >&2 "${RED}Run the following command and change the default locale to your language of choice${NC}\n\n"
        printf >&2 "${GREEN}sudo dpkg-reconfigure locales${NC}\n\n"
        printf >&2 "${RED}You will need to log out and back in for changes to take effect, then re-run this script.${NC}\n\n"
        exit 1
    fi
}


################
#  User Input  #
################

# Create usernames and passwords
generateUsersAndPass()
{
    manualpass="derp"

    DJANGO_SEKRET=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 80 | head -n 1)
    ADMINURL=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 70 | head -n 1)

    echo " "
    echo -ne "${YELLOW}If you would like to manually enter MeshCentral and Postgresql usernames and passwords${NC}\n"
    echo -ne "${YELLOW}type m for manual at the prompt, or type g to have them randomly generated for you${NC}: "
    read manualpass
    manualpass="$(translateToLowerCase $manualpass)"
    echo " "

    if [ "$manualpass" == "g" ]; then
        MESHPASSWD=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 25 | head -n 1)
        pgusername=$(cat /dev/urandom | tr -dc 'a-z' | fold -w 8 | head -n 1)
        pgpw=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 20 | head -n 1)
        meshusername=$(cat /dev/urandom | tr -dc 'a-z' | fold -w 8 | head -n 1)
    
    elif [ "$manualpass" == "m" ]; then
        passinput=""
        userconfirm="n"
        MESHPASSWD=""
        pgusername=""
        pgpw=""
        meshusername=""

        until [ "$userconfirm" == "y" ]; do
            echo " "
            echo -ne "${YELLOW}Enter the MeshCentral admin username${NC}: "
            read meshusername
            echo " "
            echo -ne "${YELLOW}Is this correct? y or n${NC}: $meshusername "
            read userconfirm
            userconfirm="$(translateToLowerCase $userconfirm)"
            if [ "$userconfirm" != "y" ]; then
                derpDerp;
            else
                echo -e "${YELLOW}Confirmed${NC}"
            fi
        done
        userconfirm="n"

        until [ "$passinput" == "$MESHPASSWD" ]; do
            read -s -p "Enter the MeshCentral admin password: " MESHPASSWD
            echo " "
            read -s -p "Re-enter the MeshCentral admin password: " passinput
            if [ "$passinput" != "$MESHPASSWD" ]; then
                echo " "
                echo -e "${YELLOW}Passwords do not match.${NC}"
                derpDerp;
            else
                echo -e "${YELLOW}Confirmed${NC}"
            fi
        done

        until [ "$userconfirm" == "y" ]; do
            echo " "
            echo -ne "${YELLOW}Enter the Postgresql admin username${NC}: "
            read pgusername
            echo " "
            echo -ne "${YELLOW}Is this correct? y or n${NC}: $pgusername "
            read userconfirm
            userconfirm="$(translateToLowerCase $userconfirm)"
            if [ "$userconfirm" != "y" ]; then
                derpDerp;
            else
                echo -e "${YELLOW}Confirmed${NC}"
            fi
        done
        userconfirm="n"

        until [ "$passinput" == "$pgpw" ]; do
            read -s -p "Enter the Postgresql admin password: " pgpw
            echo " "
            read -s -p "Re-enter the Postgresql admin password: " passinput
            if [ "$passinput" != "$pgpw" ]; then
                echo " "
                echo -e "${YELLOW}Passwords do not match.${NC}"
                derpDerp;
            else
                echo -e "${YELLOW}Confirmed${NC}"
            fi
        done
    else
        derpDerp;
    fi
}

# Get host and domain info
getHostAndDomainInfo()
{
    hostsconfirm="n"

    until [ $hostsconfirm == "y" ]; do
        rootdomain="none"
        letsemail="none"
        while [[ $rootdomain != *[.]* ]]; do
            echo -ne "${YELLOW}Enter the root domain (e.g. example.com or example.co.uk)${NC}: "
            read rootdomain
            rootdomain="$(translateToLowerCase $rootdomain)"
            echo " "
            if [[ $rootdomain != *[.]* ]]; then
                derpDerp;
            fi
        done

        echo -ne "${YELLOW}Enter the hostname for the backend (e.g. api)${NC}: "
        read rmmhost
        rmmhost="$(translateToLowerCase $rmmhost)"
        echo " "

        echo -ne "${YELLOW}Enter the hostname for the frontend (e.g. rmm)${NC}: "
        read frontendhost
        frontendhost="$(translateToLowerCase $frontendhost)"
        echo " "

        echo -ne "${YELLOW}Enter the hostname for meshcentral (e.g. mesh)${NC}: "
        read meshhost
        meshhost="$(translateToLowerCase $meshhost)"
        echo " "

        while [[ $letsemail != *[@]*[.]* ]]; do
            echo -ne "${YELLOW}Enter a valid e-mail address for django, meshcentral, and letsencrypt${NC}: "
            read letsemail 
            letsemail="$(translateToLowerCase $letsemail)"
            echo " "
            if [[ $letsemail != *[@]*[.]* ]]; then
                derpDerp;
            fi
        done

        echo " "
        echo "${YELLOW}root domain${NC}: $rootdomain"
        echo "${YELLOW}backend${NC}: $rmmhost.$rootdomain"
        echo "${YELLOW}frontend${NC}: $frontendhost.$rootdomain"
        echo "${YELLOW}meshcentral${NC}: $meshhost.$rootdomain"
        echo "${YELLOW}e-mail address${NC}: $letsemail"
        echo " "
        echo -ne "${YELLOW}Is this correct? y or n${NC}: "
        read hostsconfirm
        hostsconfirm="$(translateToLowerCase $hostsconfirm)"
        if [ "$hostsconfirm" != "y" ]; then
            derpDerp;
        else
            echo -e "${YELLOW}Confirmed${NC}"
        fi

    done

    rmmdomain="$rmmhost.$rootdomain"
    meshdomain="$meshhost.$rootdomain"
    frontenddomain="$frontendhost.$rootdomain"
}


#######################
#  Network Functions  #
#######################

# Function to set site hostnames
setSiteHostname()
{
    local textcomp="0"
    local runtimes=0
    local line1=""
    local line2=""
    until [ "$textcomp" == "" ]; do
        runtimes=$(($runtimes+1))

        # determine line number of localhost entry (this should always be the first entry)
        line1=$(sed -n "/127.0.0.1/=" /etc/hosts)

		# determine next cumulative line number
		line2=$(($line1+$runtimes))

        # read total lines after localhost
        textcomp=$(sed -n "$line2"p /etc/hosts)

        if [ "$textcomp" == "" ]; then
			sudo sed -i "${runtimes} a\127.0.1.1\t$1.$2 $1" /etc/hosts
		fi
	done

	return
}

# Check hosts file, add hosts
configHosts()
{
    # If server is behind NAT we need to add the 3 subdomains to the host file
    # so that nginx can properly route between the frontend, backend and meshcentral
    # EDIT 8-29-2020
    # running this even if server is __not__ behind NAT just to make DNS resolving faster
    # this also allows the install script to properly finish even if DNS has not fully propagated
    CHECK_LOCALHOST=$(grep "127.0.0.1 localhost" /etc/hosts)
    if ! [[ $CHECK_LOCALHOST ]]; then
        print_green 'Adding localhost to hosts file'
        sudo sed -i '1i 127.0.0.1 localhost' /etc/hosts
    fi

    CHECK_HOSTS=$(grep "127.0.1.1 $rmmdomain $frontenddomain $meshdomain" /etc/hosts)
    if [[ $CHECK_HOSTS ]]; then
        print_green 'Correcting subdomains entries'
        sudo sed -i "/127.0.1.1 $rmmdomain $frontenddomain $meshdomain/d" /etc/hosts
        setSiteHostname "$rmmhost" "$rootdomain";
        setSiteHostname "$frontendhost" "$rootdomain";
        setSiteHostname "$meshhost" "$rootdomain";
    else
        setSiteHostname "$rmmhost" "$rootdomain";
        setSiteHostname "$frontendhost" "$rootdomain";
        setSiteHostname "$meshhost" "$rootdomain";
    fi

    BEHIND_NAT=false
    IPV4=$(ip -4 addr | sed -ne 's|^.* inet \([^/]*\)/.* scope global.*$|\1|p' | head -1)
    if echo "$IPV4" | grep -qE '^(10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.|192\.168)'; then
        BEHIND_NAT=true
    fi
}


#######################
#  Install Functions  #
#######################

# Install script prereqs
installPreReqs()
{
    sudo apt update && sudo apt install -y curl wget dirmngr gnupg lsb-release ncurses-base ncurses-bin ncurses-doc ncurses-examples ncurses-term dialog libncurses5 libncursesw5 libncurses5-dev libncursesw5-dev
}

# Install remaining prereqs
installAdditionalPreReqs()
{
    sudo apt install -y software-properties-common openssl ca-certificates apt-transport-https gcc g++ make build-essential zlib1g-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libsqlite3-dev libbz2-dev git
}

# Configure repos for stuff
setInstallRepos()
{
    # There is no Jammy repo yet so use Focal for Ubuntu 22.04
    if ([ "$osname" = "ubuntu" ] && [ "$fullrelno" = "20.04" ]); then
        mongodb_repo="deb [arch=amd64] https://repo.mongodb.org/apt/$osname $codename/mongodb-org/4.4 multiverse"
    elif ([ "$osname" = "ubuntu" ] && [ "$fullrelno" = "22.04" ]); then
        codename="focal"
        mongodb_repo="deb [arch=amd64] https://repo.mongodb.org/apt/$osname $codename/mongodb-org/4.4 multiverse"
    # There is no bullseye repo yet for mongo so just use Buster on Debian 11
    elif ([ "$osname" = "debian" ] && [ $relno -eq 10 ]); then
        mongodb_repo="deb [arch=amd64] https://repo.mongodb.org/apt/$osname $codename/mongodb-org/4.4 main"
    else
        codename="buster"
        mongodb_repo="deb [arch=amd64] https://repo.mongodb.org/apt/$osname $codename/mongodb-org/4.4 main"
    fi

    postgresql_repo="deb [arch=amd64] https://apt.postgresql.org/pub/repos/apt/ $codename-pgdg main"
}

# Install MongoDB
installMongo()
{
    wget -qO - https://www.mongodb.org/static/pgp/server-4.4.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/mongo.gpg > /dev/null
    echo "$mongodb_repo" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.4.list
    sudo apt update && sudo apt install -y mongodb-org
    sudo systemctl enable mongod
    sudo systemctl restart mongod
    sleep 5
}

# Install NodeJS
installNodeJS()
{
    if [ "$1" == "update" ]; then
        HAS_NODE16=$(node --version | grep v16)
        if ! [[ $HAS_NODE16 ]]; then
            printf >&2 "${GREEN}Updating NodeJS to v16${NC}\n"
            rm -rf /rmm/web/node_modules
            sudo systemctl stop meshcentral
            sudo apt remove -y nodejs
            sudo rm -rf /usr/lib/node_modules
        fi
    fi
    curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -
    sudo apt update && sudo apt install -y nodejs
    sudo npm install -g npm
    if [ "$1" == "update" ]; then
        sudo chown ${USER}:${USER} -R /meshcentral
        cd /meshcentral
        rm -rf node_modules/
        npm install meshcentral@${LATEST_MESH_VER}
        sudo systemctl start meshcentral
    fi
}

# Install Redis
installRedis()
{
    sudo apt install -y redis
}

# Install Python
installPython()
{
    if [ "$1" == "update" ]; then
        HAS_PY310=$(python3.10 --version | grep ${PYTHON_VER})
        if ! [[ $HAS_PY310 ]]; then
            printf >&2 "${GREEN}Updating to ${PYTHON_VER}${NC}\n"
        fi
    fi

    if [ "$INSTALL_TYPE" == "devinstall" ]; then
        echo -e "${GREEN}Python already installed${NC}"
    else
        numprocs=$(nproc)
        cd ~
        wget https://www.python.org/ftp/python/${PYTHON_VER}/Python-${PYTHON_VER}.tgz
        tar -xf Python-${PYTHON_VER}.tgz
        cd Python-${PYTHON_VER}
        ./configure --enable-optimizations
        make -j $numprocs
        sudo make altinstall
        cd ~
        sudo rm -rf Python-${PYTHON_VER} Python-${PYTHON_VER}.tgz
        if [ "$INSTALL_TYPE" == "devprep" ]; then
            print_green 'All Prereqs installed'
            exit
        fi
    fi
}

# Install Postgresql
installPostgresql()
{
    echo "$postgresql_repo" | sudo tee /etc/apt/sources.list.d/pgdg.list
    wget -qO - https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/postgresql.gpg > /dev/null
    sudo apt update && sudo apt install -y postgresql-14
    sleep 2
    sudo systemctl enable postgresql
    sudo systemctl restart postgresql
    sleep 5
}

# Install NATS
installNats()
{
    if [ "$1" == "update" ]; then
        HAS_LATEST_NATS=$(/usr/local/bin/nats-server -version | grep "${NATS_SERVER_VER}")
        if ! [[ $HAS_LATEST_NATS ]]; then
            printf >&2 "${GREEN}Updating nats to v${NATS_SERVER_VER}${NC}\n"
        fi
    fi
    if [ "$1" == "install" ]; then
        NATS_SERVER_VER=$(grep "^NATS_SERVER_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')
    fi
    nats_tmp=$(mktemp -d -t nats-XXXXXXXXXX)
    wget -q https://github.com/nats-io/nats-server/releases/download/v${NATS_SERVER_VER}/nats-server-v${NATS_SERVER_VER}-linux-amd64.tar.gz -P ${nats_tmp}
    tar -xzf ${nats_tmp}/nats-server-v${NATS_SERVER_VER}-linux-amd64.tar.gz -C ${nats_tmp}
    if [ "$1" == "update" ]; then
        sudo rm -f /usr/local/bin/nats-server
    fi
    sudo mv ${nats_tmp}/nats-server-v${NATS_SERVER_VER}-linux-amd64/nats-server /usr/local/bin/
    sudo chmod +x /usr/local/bin/nats-server
    sudo chown ${USER}:${USER} /usr/local/bin/nats-server
    rm -rf ${nats_tmp}
}

# Install frontend
installFrontEnd()
{
    if [ "$1" == "update" ]; then
        if [ -d /rmm/web ]; then
            rm -rf /rmm/web
        fi

        if [ ! -d /var/www/rmm ]; then
            sudo mkdir -p /var/www/rmm
        fi
    fi

    webtar="trmm-web-v${WEB_VERSION}.tar.gz"
    wget -q "$2" -O /tmp/${webtar}
    
    if [ "$1" == "update" ]; then
        sudo rm -rf /var/www/rmm/dist
    else
        sudo mkdir -p /var/www/rmm
    fi
    sudo tar -xzf /tmp/${webtar} -C /var/www/rmm
    echo "window._env_ = {PROD_URL: \"https://${rmmdomain}\"}" | sudo tee /var/www/rmm/dist/env-config.js > /dev/null
    sudo chown www-data:www-data -R /var/www/rmm/dist
    rm -f /tmp/${webtar}
}

# Install Nginx
installNginx()
{
    if [ "$1" == "install" ]; then
	    sudo apt install -y nginx
	    sudo systemctl stop nginx
        sudo sed -i 's/worker_connections.*/worker_connections 2048;/g' /etc/nginx/nginx.conf
        sudo sed -i 's/# server_names_hash_bucket_size.*/server_names_hash_bucket_size 64;/g' /etc/nginx/nginx.conf
    elif [ "$1" == "updatepart1" ]; then
        ### Check Nginx config
        if ! sudo nginx -t > /dev/null 2>&1; then
            sudo nginx -t
            echo -ne "\n"
            echo -ne "${RED}You have syntax errors in your nginx configs. See errors above. Please fix them and re-run this script.${NC}\n"
            echo -ne "${RED}Aborting...${NC}\n"
            exit 1
        fi
    elif [ "$1" == "updatepart2" ]; then
        CHECK_NGINX_WORKER_CONN=$(grep "worker_connections 2048" /etc/nginx/nginx.conf)
        if ! [[ $CHECK_NGINX_WORKER_CONN ]]; then
            printf >&2 "${GREEN}Changing nginx worker connections to 2048${NC}\n"
            sudo sed -i 's/worker_connections.*/worker_connections 2048;/g' /etc/nginx/nginx.conf
        fi
        sudo sed -i 's/# server_names_hash_bucket_size.*/server_names_hash_bucket_size 64;/g' /etc/nginx/nginx.conf
    else
        return
    fi
}

# Install NATS Api
installNatsApi()
{
    sudo cp /rmm/natsapi/bin/nats-api /usr/local/bin
    sudo chown ${USER}:${USER} /usr/local/bin/nats-api
    sudo chmod +x /usr/local/bin/nats-api
}

# Install MeshCentral
installMeshCentral()
{
    MESH_VER=$(grep "^MESH_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')

    if [ "$1" == "install" ]; then
        sudo mkdir -p /meshcentral/meshcentral-data
    elif [ "$1" == "restore" ]; then
        sudo tar -xzf $tmp_dir/meshcentral/mesh.tar.gz -C /
    fi
    sudo chown ${USER}:${USER} -R /meshcentral
    cd /meshcentral
    npm install meshcentral@${MESH_VER}
    sudo chown ${USER}:${USER} -R /meshcentral
}


########################
#  Database Functions  #
########################

# Postgres DB creation
createPGDB()
{
	sudo -u postgres psql -c "CREATE DATABASE tacticalrmm"
	sudo -u postgres psql -c "CREATE USER ${pgusername} WITH PASSWORD '${pgpw}'"
	sudo -u postgres psql -c "ALTER ROLE ${pgusername} SET client_encoding TO 'utf8'"
	sudo -u postgres psql -c "ALTER ROLE ${pgusername} SET default_transaction_isolation TO 'read committed'"
	sudo -u postgres psql -c "ALTER ROLE ${pgusername} SET timezone TO 'UTC'"
	sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE tacticalrmm TO ${pgusername}"
}


###########################
#  Certificate Functions  #
###########################

# Install Certbot and get initial certs
installCertbot()
{
    sudo apt install -y certbot
    if [ "$1" == "restore" ]; then
        return
    fi

    if [ "$INSTALL_TYPE" == "devinstall" ]; then
        echo -e "${GREEN}Wildcard cert should be in place${NC}"
    else
        print_green 'Getting wildcard cert'

        sudo certbot certonly --manual -d *.${rootdomain} --agree-tos --no-bootstrap --preferred-challenges dns -m ${letsemail} --no-eff-email
        while [[ $? -ne 0 ]]; do
            sudo certbot certonly --manual -d *.${rootdomain} --agree-tos --no-bootstrap --preferred-challenges dns -m ${letsemail} --no-eff-email
        done

        CERT_PRIV_KEY=/etc/letsencrypt/live/${rootdomain}/privkey.pem
        CERT_PUB_KEY=/etc/letsencrypt/live/${rootdomain}/fullchain.pem

        sudo chown ${USER}:${USER} -R /etc/letsencrypt
        sudo chmod 775 -R /etc/letsencrypt

        sudo ln -s /etc/letsencrypt/live/${rootdomain}/fullchain.pem /etc/ssl/certs/fullchain.pem
		sudo ln -s /etc/letsencrypt/live/${rootdomain}/privkey.pem /etc/ssl/private/privkey.pem
    fi
}


#######################################
#  Config file and service functions  #
#######################################

# Generate mesh configuration
createMeshConfig()
{
    sudo cp /rmm/default-configs/mesh/config.json /meshcentral/meshcentral-data/config.json

    sudo sed -i "s/mesh.example.com/$meshdomain/" /meshcentral/meshcentral-data/config.json
}

# Generate local settings file
createLocalSettings()
{
    sudo cp /rmm/default-configs/python/local_settings.py /rmm/api/tacticalrmm/tacticalrmm/local_settings.py

    sudo sed -i "s/DJANGO_SEKRET/$DJANGO_SEKRET/" /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
    sudo sed -i "s/api.example.com/$rmmdomain/" /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
    sudo sed -i "s/ADMINURL/$ADMINURL/" /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
    sudo sed -i "s/rmm.example.com/$frontenddomain/" /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
    sudo sed -i "s/pgusername/$pgusername/" /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
    sudo sed -i "s/pgpw/$pgpw/" /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
    sudo sed -i "s/meshusername/$meshusername/" /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
    sudo sed -i "s/mesh.example.com/$meshdomain/" /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
}

# Backend configuration
configureBackend()
{
    SETUPTOOLS_VER=$(grep "^SETUPTOOLS_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')
    WHEEL_VER=$(grep "^WHEEL_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')

    if [ "$1" == "update" ]; then
        CHECK_CELERY_CONFIG=$(grep "autoscale=20,2" /etc/conf.d/celery.conf)
        if ! [[ $CHECK_CELERY_CONFIG ]]; then
            sudo sed -i 's/CELERYD_OPTS=.*/CELERYD_OPTS="--time-limit=86400 --autoscale=20,2"/g' /etc/conf.d/celery.conf
        fi
        CHECK_ADMIN_ENABLED=$(grep ADMIN_ENABLED /rmm/api/tacticalrmm/tacticalrmm/local_settings.py)
        if ! [[ $CHECK_ADMIN_ENABLED ]]; then
            sudo sed -i '$ a ADMIN_ENABLED = False' /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
        fi
        sudo cp /rmm/natsapi/bin/nats-api /usr/local/bin
        sudo chown ${USER}:${USER} /usr/local/bin/nats-api
        sudo chmod +x /usr/local/bin/nats-api
        if [[ "${CURRENT_PIP_VER}" != "${LATEST_PIP_VER}" ]] || [[ "$UPDATE_TYPE" == "forced" ]]; then
            rm -rf /rmm/api/env
        fi
    fi

    if [[ "${CURRENT_PIP_VER}" == "${LATEST_PIP_VER}" ]] && [[ "$UPDATE_TYPE" == "standard" ]]; then
        source /rmm/api/env/bin/activate
        cd /rmm/api/tacticalrmm
        pip install -r /rmm/api/tacticalrmm/requirements.txt
    else
        cd /rmm/api
        python3.10 -m venv env
        source /rmm/api/env/bin/activate
        cd /rmm/api/tacticalrmm
        pip install --no-cache-dir --upgrade pip
        pip install --no-cache-dir setuptools==${SETUPTOOLS_VER} wheel==${WHEEL_VER}
        pip install --no-cache-dir -r /rmm/api/tacticalrmm/requirements.txt
    fi

    if [ "$1" == "update" ]; then
        python manage.py pre_update_tasks
        celery -A tacticalrmm purge -f
        python manage.py migrate
        python manage.py delete_tokens
        python manage.py collectstatic --no-input
        python manage.py reload_nats
        python manage.py load_chocos
        python manage.py create_installer_user
        python manage.py create_natsapi_conf
        python manage.py post_update_tasks
        rmmdomain=$(python manage.py get_config api)
        WEB_VERSION=$(python manage.py get_config webversion)
        deactivate
    elif [ "$1" == "restore" ]; then
        python manage.py migrate
        python manage.py collectstatic --no-input
        python manage.py create_natsapi_conf
        python manage.py reload_nats
        python manage.py post_update_tasks
        rmmdomain=$(python manage.py get_config api)
        WEB_VERSION=$(python manage.py get_config webversion)
        deactivate
    else
        python manage.py migrate
        python manage.py collectstatic --no-input
        python manage.py create_natsapi_conf
        python manage.py load_chocos
        python manage.py load_community_scripts
        WEB_VERSION=$(python manage.py get_config webversion)
        printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
        printf >&2 "\n"
        printf >&2 "${YELLOW}Please create your login for the RMM website and django admin${NC}\n"
        printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
        printf >&2 "\n"
        echo -ne "Username: "
        read djangousername
        python manage.py createsuperuser --username ${djangousername} --email ${letsemail}
        python manage.py create_installer_user
        RANDBASE=$(python manage.py generate_totp)
        cls;
        python manage.py generate_barcode ${RANDBASE} ${djangousername} ${frontenddomain}
        deactivate
        read -n 1 -s -r -p "Press any key to continue..."
    fi
}

# Set uwsgi procs
setUwsgiProcs()
{
    uwsgiprocs=4
    if [[ "$numprocs" == "1" ]]; then
        uwsgiprocs=2
    else
        uwsgiprocs=$numprocs
    fi
}

# Create UWSGI config
createUwsgiConf()
{
    sudo cp /rmm/default-configs/uwsgi/app.ini /rmm/api/tacticalrmm/app.ini

    sudo sed -i "s/uwsgiprocs1/$uwsgiprocs/" /rmm/api/tacticalrmm/app.ini
    sudo sed -i "s/uwsgiprocs2/$uwsgiprocs/" /rmm/api/tacticalrmm/app.ini
}

# Create UWSGI service
createUwsgiService()
{
    sudo cp /rmm/service-definitions/rmm.service /etc/systemd/system/rmm.service

    sudo sed -i "s/REPLACEME/${USER}/" /etc/systemd/system/rmm.service
}

# Create Daphne service
createDaphneService()
{
    sudo cp /rmm/service-definitions/daphne.service /etc/systemd/system/daphne.service

    sudo sed -i "s/REPLACEME/${USER}/" /etc/systemd/system/daphne.service
}

# Create NATS service
createNatsService()
{
    sudo cp /rmm/service-definitions/nats.service /etc/systemd/system/nats.service

    sudo sed -i "s/REPLACEME/${USER}/" /etc/systemd/system/nats.service
}

# Create NATS service
createNatsApiService()
{
    sudo cp /rmm/service-definitions/nats-api.service /etc/systemd/system/nats-api.service

    sudo sed -i "s/REPLACEME/${USER}/" /etc/systemd/system/nats-api.service
}

# Create backend nginx conf
createBackendNginxConf()
{
    sudo cp /rmm/default-configs/nginx/rmm.conf /etc/nginx/sites-available/rmm.conf

    sudo sed -i "s/api.example.com/$rmmdomain/" /etc/nginx/sites-available/rmm.conf
    sudo sed -i "s/rmm.example.com/$frontenddomain/" /etc/nginx/sites-available/rmm.conf
}

# Create Mesh nginx conf
createMeshNginxConf()
{
    sudo cp /rmm/default-configs/nginx/meshcentral.conf /etc/nginx/sites-available/meshcentral.conf

    sudo sed -i "s/mesh.example.com/$meshdomain/" /etc/nginx/sites-available/meshcentral.conf
}

# Create Celery service
createCeleryService()
{
    sudo cp /rmm/service-definitions/celery.service /etc/systemd/system/celery.service

    sudo sed -i "s/REPLACEME/${USER}/" /etc/systemd/system/celery.service
}

# Create Celery config
createCeleryConf()
{
    sudo cp /rmm/default-configs/celery/celery.conf /etc/conf.d/celery.conf
}

# Create CeleryBeat service
createCeleryBeatService()
{
    sudo cp /rmm/service-definitions/celerybeat.service /etc/systemd/system/celerybeat.service

    sudo sed -i "s/REPLACEME/${USER}/" /etc/systemd/system/celerybeat.service
}

# Create MeshCentral service
createMeshCentralService()
{
    sudo cp /rmm/service-definitions/meshcentral.service /etc/systemd/system/meshcentral.service

    sudo sed -i "s/REPLACEME/${USER}/" /etc/systemd/system/meshcentral.service
}

# Create Frontend Nginx config
createFrontendNginxConf()
{
    sudo cp /rmm/default-configs/nginx/frontend.conf /etc/nginx/sites-available/frontend.conf

    sudo sed -i "s/rmm.example.com/$frontenddomain/" /etc/nginx/sites-available/frontend.conf
}

# Enable MeshCentral service
enableMeshService()
{
    sudo systemctl enable meshcentral
    sudo systemctl restart meshcentral
    sleep 3

    # The first time we start meshcentral, it will need some time to generate certs and install plugins.
    # This will take anywhere from a few seconds to a few minutes depending on the server's hardware
    # We will know it's ready once the last line of the systemd service stdout is 'MeshCentral HTTP server running on port.....'
    while ! [[ $CHECK_MESH_READY ]]; do
        CHECK_MESH_READY=$(sudo journalctl -u meshcentral.service -b --no-pager | grep "MeshCentral HTTP server running on port")
        echo -ne "${GREEN}Mesh Central not ready yet...${NC}\n"
        sleep 3
    done
}

# Generate Mesh Token
generateMeshToken()
{
    MESHTOKENKEY="$(node /meshcentral/node_modules/meshcentral --logintokenkey)"

    sudo sed -i '$ a MESH_TOKEN_KEY = "MESHTOKENKEY"' /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
    sudo sed -i "s/MESHTOKENKEY/$MESHTOKENKEY/" /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
}

# Configure Mesh user and group, restart service
configMeshUserGroup()
{
    sudo systemctl stop meshcentral
    sleep 1
    cd /meshcentral

    node node_modules/meshcentral --createaccount ${meshusername} --pass ${MESHPASSWD} --email ${letsemail}
    sleep 1
    node node_modules/meshcentral --adminaccount ${meshusername}

    sudo systemctl start meshcentral
    sleep 5

    while ! [[ $CHECK_MESH_READY2 ]]; do
        CHECK_MESH_READY2=$(sudo journalctl -u meshcentral.service -b --no-pager | grep "MeshCentral HTTP server running on port")
        echo -ne "${GREEN}Mesh Central not ready yet...${NC}\n"
        sleep 3
    done

    node node_modules/meshcentral/meshctrl.js --url wss://${meshdomain} --loginuser ${meshusername} --loginpass ${MESHPASSWD} AddDeviceGroup --name TacticalRMM
    sleep 1
}

# Configure and enable NATS service
enableNatsService()
{
    sudo systemctl enable nats.service
    cd /rmm/api/tacticalrmm
    source /rmm/api/env/bin/activate
    python manage.py initial_db_setup
    python manage.py reload_nats
    deactivate
    sudo systemctl start nats.service

    sleep 1
    sudo systemctl enable nats-api.service
    sudo systemctl start nats-api.service
}


###########################################
#  Update and Restore specific functions  #
###########################################

# Check that user is same as during install
checkSameUser()
{
    strip="User="
    if [ "$1" == "update" ]; then
        ORIGUSER=$(grep ${strip} /etc/systemd/system/rmm.service | sed -e "s/^${strip}//")
    elif [ "$1" == "restore" ]; then
        ORIGUSER=$(grep ${strip} $tmp_dir/systemd/rmm.service | sed -e "s/^${strip}//")
    fi
    if [ "$ORIGUSER" != "$USER" ]; then
        printf >&2 "${RED}ERROR: You must run this update script from the same user account used during install: ${GREEN}${ORIGUSER}${NC}\n"
        if [ "$1" == "restore" ]; then
            rm -rf $tmp_dir
        fi
        exit 1
    fi
}

# Check if T-RMM update is necessary
checkIfUpdate()
{
    TMP_SETTINGS=$(mktemp -p "" "rmmsettings_XXXXXXXXXX")
    curl -s -L "${LATEST_SETTINGS_URL}" > ${TMP_SETTINGS}

    LATEST_TRMM_VER=$(grep "^TRMM_VERSION" "$TMP_SETTINGS" | awk -F'[= "]' '{print $5}')
    CURRENT_TRMM_VER=$(grep "^TRMM_VERSION" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')

    if [[ "${CURRENT_TRMM_VER}" == "${LATEST_TRMM_VER}" ]] && [[ "$UPDATE_TYPE" == "standard" ]]; then
        printf >&2 "${GREEN}Already on latest version. Current version: ${CURRENT_TRMM_VER} Latest version: ${LATEST_TRMM_VER}${NC}\n"
        rm -f $TMP_SETTINGS
        exit 0
    fi
}

# Get current versions of necessary included apps
checkAdditionalAppsVers()
{
    LATEST_MESH_VER=$(grep "^MESH_VER" "$TMP_SETTINGS" | awk -F'[= "]' '{print $5}')
    LATEST_PIP_VER=$(grep "^PIP_VER" "$TMP_SETTINGS" | awk -F'[= "]' '{print $5}')
    NATS_SERVER_VER=$(grep "^NATS_SERVER_VER" "$TMP_SETTINGS" | awk -F'[= "]' '{print $5}')
    CURRENT_PIP_VER=$(grep "^PIP_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')
}

# Check CHECK_NATS_LIMITNOFILE, whatever that means
checkNatsLimitNoFile()
{
    CHECK_NATS_LIMITNOFILE=$(grep LimitNOFILE /etc/systemd/system/nats.service)
    if ! [[ $CHECK_NATS_LIMITNOFILE ]]; then

        sudo rm -f /etc/systemd/system/nats.service
        createNatsService;
        sudo systemctl daemon-reload
    fi
}

# Disable Redis append only
turnOffRedisAppendOnly()
{
    printf >&2 "${GREEN}Turning off redis aof${NC}\n"
    sudo redis-cli config set appendonly no
    sudo redis-cli config rewrite
    sudo rm -f /var/lib/redis/appendonly.aof
}

# Update MeshCentral
updateMeshCentral()
{
    CURRENT_MESH_VER=$(cd /meshcentral/node_modules/meshcentral && node -p -e "require('./package.json').version")
    if [[ "${CURRENT_MESH_VER}" != "${LATEST_MESH_VER}" ]] || [[ "$force" = true ]]; then
        printf >&2 "${GREEN}Updating meshcentral from ${CURRENT_MESH_VER} to ${LATEST_MESH_VER}${NC}\n"
        sudo systemctl stop meshcentral
        sudo chown ${USER}:${USER} -R /meshcentral
        cd /meshcentral
        rm -rf node_modules/
        npm install meshcentral@${LATEST_MESH_VER}
        sudo systemctl start meshcentral
    fi
}

# Get backup location
getBackupFileLocation()
{
    backuppath=""
    userconfirm="n"

    until [ "$userconfirm" == "y" ]; do
        echo " "
        echo -ne "${YELLOW}Enter the full path to the backup file, including filename${NC}: "
        read backuppath
        echo " "
        if [ ! -f "$backuppath" ]; then
            derpDerp;
        else
            echo -e "${YELLOW}Confirmed${NC}"
            userconfirm="y"
        fi
    done
    userconfirm="n"
}

# Extract backup
extractBackup()
{
    print_green 'Unpacking backup'
    tmp_dir=$(mktemp -d -t tacticalrmm-XXXXXXXXXXXXXXXXXXXXX)

    tar -xf ${1} -C $tmp_dir
}


###############################
#  Troubleshooting functions  #
###############################

# Ping to test if domain is live
pingDomain()
{
    if ping -c 1 $1 &> /dev/null
    then
        echo -ne "${GREEN} Verified $1${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    else
        echo -ne "${RED} $1 doesnt exist please create it or check for a typo.${NC}" | tee -a checklog.log
        printf >&2 "\n\n"
        printf >&2 "You will have a log file called checklog.log in the directory you ran this script from.${NC}"
        printf >&2 "\n\n"
        exit
    fi
}

# Check IPs
checkIPisLive()
{
    locinputip=`dig @"$locdns" +short $1`
    reminputip=`dig @8.8.8.8 +short $1`

    if [ "$locinputip" = "$reminputip" ]; then
        echo -ne "${GREEN} Success $1 is Locally Resolved: ${locinputip}  Remotely Resolved: ${reminputip}${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    else
	    echo -ne "${RED} Locally Resolved: ${locinputip}  Remotely Resolved: ${reminputip}${NC}" | tee -a checklog.log
	    printf >&2 "\n\n" | tee -a checklog.log
        echo -ne "${RED} Your Local and Remote IP for $1 all agents will require non-public DNS to find TRMM server.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    fi
}

# Check services status
readServicesStatus()
{
    rmmstatus=$(systemctl is-active rmm)
    daphnestatus=$(systemctl is-active daphne)
    celerystatus=$(systemctl is-active celery)
    celerybeatstatus=$(systemctl is-active celerybeat)
    nginxstatus=$(systemctl is-active nginx)
    natsstatus=$(systemctl is-active nats)
    natsapistatus=$(systemctl is-active nats-api)
    meshcentralstatus=$(systemctl is-active meshcentral)
    mongodstatus=$(systemctl is-active mongod)
    postgresqlstatus=$(systemctl is-active postgresql)
    redisserverstatus=$(systemctl is-active redis-server)
}

# Verify services active
checkIfServiceActive()
{
    if [ $1 = active ]; then
        echo -ne "${GREEN} Success $2 is Running.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    else
	    printf >&2 "\n\n" | tee -a checklog.log
        echo -ne "${RED} $2 is not running. \(Tactical will not work without this\)${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
fi
}

# Check for open ports
isPortOpen()
{
    if ( nc -zv $wanip $1 2>&1 >/dev/null ); then
        echo -ne "${GREEN} $2 Port is open.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    else
        echo -ne "${RED} $2 port is closed. \(you may want this if running locally only\)${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    fi
}

# Check proxy
checkProxy()
{
    echo -ne "${YELLOW} Checking For Proxy.${NC}" | tee -a checklog.log 
	printf >&2 "\n\n"
	echo -ne "${YELLOW} ......this might take a while!!${NC}"
	printf >&2 "\n\n"

    # Detect Proxy via cert
    proxyext=$(openssl s_client -showcerts -servername $remapiip -connect $remapiip:443 2>/dev/null | openssl x509 -inform pem -noout -text)
    proxyint=$(openssl s_client -showcerts -servername 127.0.0.1 -connect 127.0.0.1:443 2>/dev/null | openssl x509 -inform pem -noout -text)

    if [[ $proxyext == $proxyint ]]; then
        echo -ne "${GREEN} No Proxy detected using Certificate.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    else
        echo -ne "${YELLOW} Proxy detected using Certificate.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    fi

    # Detect Proxy via IP
    if [ $wanip != $remrmmip ]; then
        echo -ne "${YELLOW} Proxy detected using IP.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    else
        echo -ne "${GREEN} No Proxy detected using IP.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    fi
}

# Check for valid cert
checkIfCertIsValid()
{
    echo -ne "${YELLOW} Checking if SSL Certificate is up to date.${NC}" | tee -a checklog.log 
	printf >&2 "\n\n"

    # SSL Certificate check
    cert=$(openssl verify -CAfile /etc/letsencrypt/live/$rootdomain/chain.pem /etc/letsencrypt/live/$rootdomain/cert.pem)

    if [[ "$cert" == *"OK"* ]]; then
        echo -ne "${GREEN} SSL Certificate for $rootdomain is fine.${NC}"  | tee -a checklog.log
	    printf >&2 "\n\n"
    else
        echo -ne "${RED} SSL Certificate has expired or doesnt exist for $rootdomain.${NC}"  | tee -a checklog.log
	    printf >&2 "\n\n"
    fi
}


######################
#  Parent Functions  #
######################

# Main install function
mainInstall()
{
    ### Repo info for Postegres and Mongo
    setInstallRepos;

    ### Create usernames and passwords
    generateUsersAndPass;

    ### This does... something
    cls;

    ### Get host/domain info
    getHostAndDomainInfo;

    ### Configure hosts file
    print_green 'Configuring Hosts file'
    configHosts;

    ### Certificate generation
    print_green 'Installing Certbot'
    installCertbot;

    ### Install Nginx
    print_green 'Installing Nginx'
    installNginx;

    ### Install NodeJS
    print_green 'Installing NodeJS'
    installNodeJS;

    ### Install and enable MongoDB
    print_green 'Installing MongoDB'
    installMongo;

    ### Install Python
    print_green "Installing Python ${PYTHON_VER}"
    installPython;

    ### Installing Redis
    print_green 'Installing redis'
    installRedis;

    ### Install and enable Postgresql
    print_green 'Installing postgresql'
    installPostgresql;

    ### Postgres DB creation
    print_green 'Creating database for the rmm'
    createPGDB;

    ### Clone main repo
    print_green 'Cloning primary repo'
    clonePrimaryRepo "install" "$REPO_URL" "$BRANCH";
  
    ### Clone scripts repo
    print_green 'Cloning community scripts repo'
    cloneScriptsRepo "install" "$SCRIPTS_REPO_URL";

    ### Installing NATS
    print_green 'Installing NATS'
    installNats "$INSTALL_TYPE";

    ### Install MeshCentral
    print_green 'Installing MeshCentral'
    installMeshCentral "install";
  
    ### Create MeshCentral config
    print_green 'Generating MeshCentral Config'
    createMeshConfig;

    ### Create local settings file
    print_green 'Generating Local Settings'
    createLocalSettings;

    ### Install NATS-API and correct permissions
    print_green 'Installing NATS API'
    installNatsApi;

    ### Install backend, configure primary admin user, setup admin 2fa
    print_green 'Installing the backend'
    configureBackend "install";
    
    ### Determine Proc setting for UWSGI
    print_green 'Optimizing UWSGI for number of processors'
    setUwsgiProcs;

    ### Create UWSGI config
    print_green 'Creating UWSGI configuration'
    createUwsgiConf;

    ### Create RMM UWSGI systemd service
    print_green 'Creating UWSGI service'
    createUwsgiService;

    ### Create Daphne systemd service
    print_green 'Creating Daphne service'
    createDaphneService;

    ### Create NATS systemd service
    print_green 'Creating NATS service'
    createNatsService;

    ### Create NATS-api systemd service
    print_green 'Creating NATS-API service'
    createNatsApiService;

    ### Create Backend Nginx site config
    print_green 'Creating Backend Nginx config'
    createBackendNginxConf;

    ### Create MeshCentral Nginx configuration
    print_green 'Creating MeshCentral Nginx config'
    createMeshNginxConf;

    ### Enable Mesh and RMM sites
    sudo ln -s /etc/nginx/sites-available/rmm.conf /etc/nginx/sites-enabled/rmm.conf
    sudo ln -s /etc/nginx/sites-available/meshcentral.conf /etc/nginx/sites-enabled/meshcentral.conf

    ### Create conf directory
    sudo mkdir /etc/conf.d

    ### Create Celery systemd service
    print_green 'Creating Celery service'
    createCeleryService;

    ### Configure Celery service
    print_green 'Creating Celery config'
    createCeleryConf;

    ### Create CeleryBeat systemd service
    print_green 'Creating CeleryBeat service'
    createCeleryBeatService;

    ### Correct conf dir ownership
    sudo chown ${USER}:${USER} -R /etc/conf.d/

    ### Create MeshCentral systemd service
    print_green 'Creating MeshCentral service'
    createMeshCentralService;

    ### Update services info
    sudo systemctl daemon-reload

    ### Verify and correct permissions
    if [ -d ~/.npm ]; then
        sudo chown -R $USER:$GROUP ~/.npm
    fi

    if [ -d ~/.config ]; then
        sudo chown -R $USER:$GROUP ~/.config
    fi

    ### Install frontend
    print_green 'Installing the frontend'
    installFrontEnd "install" "$FRONTEND_URL";

    ### Set front end Nginx config and enable
    print_green 'Creating Frontend Nginx config'
    createFrontendNginxConf;

    ### Enable Frontend site
    sudo ln -s /etc/nginx/sites-available/frontend.conf /etc/nginx/sites-enabled/frontend.conf

    ### Enable RMM, Daphne, Celery, and Nginx services
    print_green 'Enabling Services'

    for i in rmm.service daphne.service celery.service celerybeat.service nginx
    do
        sudo systemctl enable ${i}
        sudo systemctl stop ${i}
        sudo systemctl start ${i}
    done
    sleep 5

    ### Enable MeshCentral service
    print_green 'Starting meshcentral and waiting for it to install plugins'
    enableMeshService;

    ### Generating MeshCentral key
    print_green 'Generating meshcentral login token key'
    generateMeshToken;

    ### Configuring MeshCentral admin user and device group, restart service
    print_green 'Creating meshcentral account and group'
    configMeshUserGroup;

    ### Enable and configure NATS service
    print_green 'Starting NATS service'
    enableNatsService;

    ### Disable django admin
    sed -i 's/ADMIN_ENABLED = True/ADMIN_ENABLED = False/g' /rmm/api/tacticalrmm/tacticalrmm/local_settings.py

    ### Restart core services
    print_green 'Restarting services'

    for i in rmm.service daphne.service celery.service celerybeat.service
    do
        sudo systemctl stop ${i}
        sudo systemctl start ${i}
    done

    ### Yay, we're done!
    printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
    printf >&2 "\n\n"
    printf >&2 "${YELLOW}Installation complete!${NC}\n\n"
    printf >&2 "${YELLOW}Access your rmm at: ${GREEN}https://${frontenddomain}${NC}\n\n"
    printf >&2 "${YELLOW}Django admin url (disabled by default): ${GREEN}https://${rmmdomain}/${ADMINURL}/${NC}\n\n"
    printf >&2 "${YELLOW}MeshCentral username: ${GREEN}${meshusername}${NC}\n"
    printf >&2 "${YELLOW}MeshCentral password: ${GREEN}${MESHPASSWD}${NC}\n\n"

    if [ "$BEHIND_NAT" = true ]; then
        echo -ne "${YELLOW}Read below if your router does NOT support Hairpin NAT${NC}\n\n"
        echo -ne "${GREEN}If you will be accessing the web interface of the RMM from the same LAN as this server,${NC}\n"
        echo -ne "${GREEN}you'll need to make sure your 3 subdomains resolve to ${IPV4}${NC}\n"
        echo -ne "${GREEN}This also applies to any agents that will be on the same local network as the rmm.${NC}\n"
        echo -ne "${GREEN}You'll also need to setup port forwarding in your router on ports 80, 443 and 4222 tcp.${NC}\n\n"
    fi

    printf >&2 "${YELLOW}Please refer to the github README for next steps${NC}\n\n"
    printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
    printf >&2 "\n"

    return
}

# Update function
updateTRMM()
{
    ### Check if user is same as during installation
    checkSameUser "update";

    ### Get current release version and check if update is necessary
    checkIfUpdate;

    ### Get current versions of necessary included apps
    checkAdditionalAppsVers;

    ### This does... something
    cls;

    ### Check CHECK_NATS_LIMITNOFILE, whatever that means
    checkNatsLimitNoFile;

    ### Check Nginx config
    installNginx "updatepart1";

    ### Stop services
    for i in nginx nats-api nats rmm daphne celery celerybeat
    do
        printf >&2 "${GREEN}Stopping ${i} service...${NC}\n"
        sudo systemctl stop ${i}
    done

    ### Rebuild uwsgi config
    rm -f /rmm/api/tacticalrmm/app.ini
    setUwsgiProcs;
    createUwsgiConf;

    ### Check additional Nginx settings and update
    installNginx "updatepart2";

    ### Check if Python is up to date, if not, update
    installPython "update";

    ### Check if NATS is up to date, if not, update
    installNats "update";

    ### This does stuff
    if [ -d ~/.npm ]; then
        sudo rm -rf ~/.npm
    fi

    if [ -d ~/.cache ]; then
        sudo rm -rf ~/.cache
    fi

    if [ -d ~/.config ]; then
        sudo chown -R $USER:$GROUP ~/.config
    fi

    ### Check NodeJS version, update if needed and update MeshCentral
    print_green 'Updating NodeJS'
    installNodeJS "update";

    ### Update from main repo
    print_green 'Cloning primary repo'
    clonePrimaryRepo "update" "$REPO_URL" "$BRANCH";

    ### Update from community-scripts repo
    print_green 'Cloning community scripts repo'
    cloneScriptsRepo "update" "$SCRIPTS_REPO_URL";

    ### Apply updated Ownership and perms
    sudo chown ${USER}:${USER} -R /rmm
    sudo chown ${USER}:${USER} -R ${SCRIPTS_DIR}
    sudo chown ${USER}:${USER} /var/log/celery
    sudo chown ${USER}:${USER} -R /etc/conf.d/
    sudo chown ${USER}:${USER} -R /etc/letsencrypt
    sudo chmod 775 -R /etc/letsencrypt

    ### Reconfigure backend
    configureBackend "update";

    ### Disable Redis append only
    turnOffRedisAppendOnly;

    ### Update Frontend
    installFrontEnd "update" "$FRONTEND_URL";

    ### Start services
    for i in nats nats-api rmm daphne celery celerybeat nginx
    do
        printf >&2 "${GREEN}Starting ${i} service${NC}\n"
        sudo systemctl start ${i}
    done
    sleep 1

    ### Push agent updates
    /rmm/api/env/bin/python /rmm/api/tacticalrmm/manage.py update_agents

    ### Update MeshCentral if necessary
    updateMeshCentral;

    ### Cleanup
    rm -f $TMP_SETTINGS

    ### Bye-bye
    printf >&2 "${GREEN}Update finished!${NC}\n"

    return
}

# Backup Function
backupTRMM()
{
    ### Pull Postgres info
    POSTGRES_USER=$(grep -w USER /rmm/api/tacticalrmm/tacticalrmm/local_settings.py | sed 's/^.*: //' | sed 's/.//' | sed -r 's/.{2}$//')
    POSTGRES_PW=$(grep -w PASSWORD /rmm/api/tacticalrmm/tacticalrmm/local_settings.py | sed 's/^.*: //' | sed 's/.//' | sed -r 's/.{2}$//')

    ### Check if rmmbackup folder exists, if not create it
    if [ ! -d /rmmbackups ]; then
        sudo mkdir /rmmbackups
        sudo chown ${USER}:${USER} /rmmbackups
    fi

    ### Remove old MeshCentral backups
    if [ -d /meshcentral/meshcentral-backup ]; then
        rm -rf /meshcentral/meshcentral-backup/*
    fi

    ### Remove old MeshCentral DB backups
    if [ -d /meshcentral/meshcentral-coredumps ]; then
        rm -f /meshcentral/meshcentral-coredumps/*
    fi

    ### Set info for backup and folders
    dt_now=$(date '+%Y_%m_%d__%H_%M_%S')
    tmp_dir=$(mktemp -d -t tacticalrmm-XXXXXXXXXXXXXXXXXXXXX)
    sysd="/etc/systemd/system"

    ### Create temp backup subdirectories
    mkdir -p ${tmp_dir}/meshcentral/mongo
    mkdir ${tmp_dir}/postgres
    mkdir ${tmp_dir}/certs
    mkdir ${tmp_dir}/nginx
    mkdir ${tmp_dir}/systemd
    mkdir ${tmp_dir}/rmm
    mkdir ${tmp_dir}/confd

    ### Dump Postgres database
    pg_dump --dbname=postgresql://"${POSTGRES_USER}":"${POSTGRES_PW}"@127.0.0.1:5432/tacticalrmm | gzip -9 > ${tmp_dir}/postgres/db-${dt_now}.psql.gz

    ### Backup Mesh stuff
    tar -czvf ${tmp_dir}/meshcentral/mesh.tar.gz --exclude=/meshcentral/node_modules /meshcentral
    mongodump --gzip --out=${tmp_dir}/meshcentral/mongo

    ### Backup certs
    sudo tar -czvf ${tmp_dir}/certs/etc-letsencrypt.tar.gz -C /etc/letsencrypt .

    ### Backup Nginx configs
    sudo tar -czvf ${tmp_dir}/nginx/etc-nginx.tar.gz -C /etc/nginx .

    ### Backup other config files
    sudo tar -czvf ${tmp_dir}/confd/etc-confd.tar.gz -C /etc/conf.d .

    ### Copy service files
    sudo cp ${sysd}/rmm.service ${sysd}/celery.service ${sysd}/celerybeat.service ${sysd}/meshcentral.service ${sysd}/nats.service ${sysd}/daphne.service ${tmp_dir}/systemd/
    if [ -f "${sysd}/nats-api.service" ]; then
        sudo cp ${sysd}/nats-api.service ${tmp_dir}/systemd/
    fi

    cat /rmm/api/tacticalrmm/tacticalrmm/private/log/django_debug.log | gzip -9 > ${tmp_dir}/rmm/debug.log.gz
    cp /rmm/api/tacticalrmm/tacticalrmm/local_settings.py ${tmp_dir}/rmm/

    tar -cf /rmmbackups/rmm-backup-${dt_now}.tar -C ${tmp_dir} .

    ### Remove temp files/folders
    rm -rf ${tmp_dir}

    echo -ne "${GREEN}Backup saved to /rmmbackups/rmm-backup-${dt_now}.tar${NC}\n"

    return
}

# Restore T-RMM
restoreTRMM()
{
    ### Repo info for Postegres and Mongo
    setInstallRepos;

    ### Get backup file location
    getBackupFileLocation;

    ### Extract backup
    extractBackup "$backuppath";

    ### Check if original user
    checkSameUser "restore";

    ### Install NodeJS
    print_green 'Installing NodeJS'
    installNodeJS "install";

    ### Install Nginx
    print_green 'Installing Nginx'
    installNginx "install";

    ### Restore Nginx configuration
    print_green 'Restoring Nginx configuration'

    sudo rm -rf /etc/nginx
    sudo mkdir /etc/nginx
    sudo tar -xzf $tmp_dir/nginx/etc-nginx.tar.gz -C /etc/nginx
    sudo sed -i 's/worker_connections.*/worker_connections 2048;/g' /etc/nginx/nginx.conf
    rmmdomain=$(grep server_name /etc/nginx/sites-available/rmm.conf | grep -v 301 | head -1 | tr -d " \t" | sed 's/.*server_name//' | tr -d ';')
    frontenddomain=$(grep server_name /etc/nginx/sites-available/frontend.conf | grep -v 301 | head -1 | tr -d " \t" | sed 's/.*server_name//' | tr -d ';')
    meshdomain=$(grep server_name /etc/nginx/sites-available/meshcentral.conf | grep -v 301 | head -1 | tr -d " \t" | sed 's/.*server_name//' | tr -d ';')

    ### Restore hosts config
    configHosts;

    ### Restore Certbot
    print_green 'Installing Certbot'
    installCertbot "restore";

    ### Restoring existing certs
    print_green 'Restoring certs'

    sudo rm -rf /etc/letsencrypt
    sudo mkdir /etc/letsencrypt
    sudo tar -xzf $tmp_dir/certs/etc-letsencrypt.tar.gz -C /etc/letsencrypt
    sudo chown ${USER}:${USER} -R /etc/letsencrypt
    sudo chmod 775 -R /etc/letsencrypt

    ### Restore Celery configs
    print_green 'Restoring celery configs'

    sudo mkdir /etc/conf.d
    sudo tar -xzf $tmp_dir/confd/etc-confd.tar.gz -C /etc/conf.d
    sudo chown ${USER}:${USER} -R /etc/conf.d

    ### Restoring services
    print_green 'Restoring systemd services'

    sudo cp $tmp_dir/systemd/* /etc/systemd/system/
    sudo systemctl daemon-reload

    ### Install Python
    print_green "Installing Python ${PYTHON_VER}"
    installPython;

    ### Installing Redis
    print_green 'Installing redis'
    installRedis;

    ### Install and enable Postgresql
    print_green 'Installing postgresql'
    installPostgresql;

    ### Install and enable MongoDB
    print_green 'Installing MongoDB'
    installMongo;

    ### Restore Mongo database
    print_green 'Restoring MongoDB'
    mongorestore --gzip $tmp_dir/meshcentral/mongo

    ### Clone main repo
    print_green 'Cloning primary repo'
    clonePrimaryRepo "install" "$REPO_URL" "$BRANCH";

    ### Clone scripts repo
    print_green 'Cloning community scripts repo'
    cloneScriptsRepo "install" "$SCRIPTS_REPO_URL";

    ### Installing NATS
    print_green 'Installing NATS'
    installNats "install";

    ### Restore MeshCentral
    print_green 'Restoring MeshCentral'
    installMeshCentral "restore";

    ### Restore UWSGI
    print_green 'Optimizing UWSGI for number of processors'
    setUwsgiProcs;
    print_green 'Creating UWSGI configuration'
    createUwsgiConf;

    ### Restoring other misc stuff
    cp $tmp_dir/rmm/local_settings.py /rmm/api/tacticalrmm/tacticalrmm/
    cp $tmp_dir/rmm/env /rmm/web/.env
    gzip -d $tmp_dir/rmm/debug.log.gz
    cp $tmp_dir/rmm/django_debug.log /rmm/api/tacticalrmm/tacticalrmm/private/log/

    ### Install NATS-API
    print_green 'Installing NATS API'
    installNatsApi;

    ### Restore Postgres database
    print_green 'Restoring the Postgres database'

    pgusername=$(grep -w USER /rmm/api/tacticalrmm/tacticalrmm/local_settings.py | sed 's/^.*: //' | sed 's/.//' | sed -r 's/.{2}$//')
    pgpw=$(grep -w PASSWORD /rmm/api/tacticalrmm/tacticalrmm/local_settings.py | sed 's/^.*: //' | sed 's/.//' | sed -r 's/.{2}$//')
    
    sudo -u postgres psql -c "DROP DATABASE IF EXISTS tacticalrmm"
    createPGDB;

    gzip -d $tmp_dir/postgres/*.psql.gz
    PGPASSWORD=${pgpw} psql -h localhost -U ${pgusername} -d tacticalrmm -f $tmp_dir/postgres/db*.psql

    ### Restore Backend
    print_green 'Restoring the backend'
    configureBackend "restore";

    ### Start NATS
    print_green 'Start NATS'
    sudo systemctl enable nats.service
    sudo systemctl start nats.service

    ### Install frontend
    print_green 'Installing the frontend'
    installFrontEnd;

    # reset perms
    sudo chown ${USER}:${USER} -R /rmm
    sudo chown ${USER}:${USER} /var/log/celery
    sudo chown ${USER}:${USER} -R /etc/conf.d/
    sudo chown -R $USER:$GROUP /home/${USER}/.npm
    sudo chown -R $USER:$GROUP /home/${USER}/.config
    sudo chown -R $USER:$GROUP /home/${USER}/.cache

    ### Update services info
    sudo systemctl daemon-reload

    ### Enable RMM, Daphne, Celery, Nats-api, and Nginx services
    print_green 'Enabling Services'

    for i in celery.service celerybeat.service rmm.service daphne.service nats-api.service nginx
    do
        sudo systemctl enable ${i}
        sudo systemctl stop ${i}
        sudo systemctl start ${i}
    done
    sleep 5

    ### Start MeshCentral
    print_green 'Starting meshcentral'
    sudo systemctl enable meshcentral
    sudo systemctl start meshcentral

    ### Done!!!!
    printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
    printf >&2 "\n\n"
    printf >&2 "${YELLOW}Restore complete!${NC}\n\n"
    printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
    printf >&2 "\n"

    return
}

# Troubleshooting utility
troubleShoot()
{
    ### Resolve Locally used DNS server
    locdns=$(resolvectl | grep 'Current DNS Server:' | cut -d: -f2 | awk '{ print $1}')

    ### Prompt for host, domain, and email info
    getHostAndDomainInfo;

    ### Verify domains are live
    pingDomain "$rmmdomain";
    pingDomain "$frontenddomain";
    pingDomain "$meshdomain";

    ### Verify IPs
    echo -ne ${YELLOW} Checking IPs | tee -a checklog.log 
	printf >&2 "\n\n"
    checkIPisLive "$rmmdomain";
    remapiip="${reminputip}"
    checkIPisLive "$frontenddomain";
    checkIPisLive "$meshdomain";

    ### Get services status
    readServicesStatus;

    ### Verify services active
    checkIfServiceActive "$rmmstatus" "RMM Service";
    checkIfServiceActive "$daphnestatus" "Daphne Service";
    checkIfServiceActive "$celerystatus" "Celery Service";
    checkIfServiceActive "$celerybeatstatus" "CeleryBeat Service";
    checkIfServiceActive "$nginxstatus" "Nginx Service";
    checkIfServiceActive "$natsstatus" "NATS Service";
    checkIfServiceActive "$natsapistatus" "NATS-API Service";
    checkIfServiceActive "$meshcentralstatus" "MeshCentral Service";
    checkIfServiceActive "$mongodstatus" "MongoD Service";
    checkIfServiceActive "$postgresqlstatus" "Postgresql Service";
    checkIfServiceActive "$redisserverstatus" "Redis-Server Service";

    ### Get WAN IP
    wanip=$(dig @resolver4.opendns.com myip.opendns.com +short)
    echo -ne "${GREEN} WAN IP is $wanip.${NC}" | tee -a checklog.log
    printf >&2 "\n\n"

    ### Check if ports are open
    isPortOpen "4222" "NATS";
    isPortOpen "80" "HTTP";
    isPortOpen "443" "HTTPS";
    
    ### Checking Proxy
    checkProxy;

    ### Check for valid cert
    checkIfCertIsValid;

    ### Generate log summary
    echo -ne "${YELLOW} Getting summary output of logs.${NC}" | tee -a checklog.log  

    tail /rmm/api/tacticalrmm/tacticalrmm/private/log/django_debug.log  | tee -a checklog.log
	printf >&2 "\n\n"
    tail /rmm/api/tacticalrmm/tacticalrmm/private/log/error.log  | tee -a checklog.log
	printf >&2 "\n\n"

    printf >&2 "\n\n"
    echo -ne "${YELLOW} You will have a log file called checklog.log in the directory you ran this script from.${NC}"
    printf >&2 "\n\n"

    return
}