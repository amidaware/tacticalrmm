########################
#  Input verification  #
########################

errortrack=0

# Translate user input to all lower case to prevent ID10T errors
translateToLowerCase()
{
	local lowercase=""
	lowercase="$(echo $1 | tr '[:upper:]' '[:lower:]')"
	echo "$lowercase"
}

# Function to track ID10T errors
derpDerp()
{
	if [ "$errortrack" -lt 12 ]; then
		errortrack=$((errortrack+1))
	fi

    derptext=""

	case $errortrack in
		1 ) derptext="Need some coffee?\n";;
		2 ) derptext="You should get some coffee.\n";;
		3 ) derptext="You are paying attention, right?\n";;
		4 ) derptext="All your typos are belong to us.\n";;
		5 ) derptext="We're sorry, your fingers are too fat.\n\nIf you would like to obtain a typing wand,\nplease mash your hand on the keyboard now.\n";;
		6 ) derptext="You have got to be kidding me...\n";;
		7 ) derptext="You're doing this intentionally, aren't you?\n";;
		8 ) derptext="Please step away from the keyboard, and back away slowly.\n";;
		9 ) derptext="You're making me angry. You wouldn't like me when I'm angry.\n";;
		10 ) derptext="How did you even get to this point?!?!?!?!\n";;
		11 ) derptext="Seriously, just give it up.\n";;
        * ) derptext="\*sigh\* Why are you still here?\n";;
	esac

    if [ "$errortrack" -lt 6 ]; then
        echo " "
        echo -e "${GREEN}${derptext}${NC}"
        echo -ne "${GREEN}Press any key to try again:${NC} "
        read anykey
        echo " "
    elif [ "$errortrack" -ge 6 ] && [ "$errortrack" -lt 10 ]; then
        echo " "
        echo -e "${YELLOW}${derptext}${NC}"
        echo -ne "${YELLOW}This really isn't that difficult. Press any key to try again:${NC} "
        read anykey
        echo " "
    elif [ "$errortrack" -ge 10 ]; then
        echo " "
        echo -e "${RED}${derptext}${NC}"
        echo -ne "${RED}The instructions are literally right there. Press any key to try again:${NC} "
        read anykey
        echo " "
    fi
	return
}

#######################################################################################
#  Misc Functions and variables, must be before any but input verification functions  #
#######################################################################################

CFG_VERSION="2"
CFG_URL='https://raw.githubusercontent.com/ninjamonkey198206/tacticalrmm/develop-bash-updates/bashfunctions.cfg'

# Set bash text colors
setColors()
{
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    RED='\033[0;31m'
    NC='\033[0m'
}

# Not defined
cls()
{
  printf "\033c"
}

# Purty install text
print_green()
{
  printf >&2 "${GREEN}%0.s-${NC}" {1..80}
  printf >&2 "\n"
  printf >&2 "${GREEN}${1}${NC}\n"
  printf >&2 "${GREEN}%0.s-${NC}" {1..80}
  printf >&2 "\n"
}

# Check for new script version
checkScriptVer()
{
    TMP_FILE=$(mktemp -p "" "rmminstall_XXXXXXXXXX")
    curl -s -L "$2" > ${TMP_FILE}
    NEW_VER=$(grep "^SCRIPT_VERSION" "$TMP_FILE" | awk -F'[="]' '{print $3}')

    if [ "$1" -ne "${NEW_VER}" ]; then
        printf >&2 "${YELLOW}Old $3 detected, downloading and replacing with the latest version...${NC}\n"
        wget -q "$2" -O $3
        printf >&2 "${YELLOW}Script updated! Please re-run .$3${NC}\n"
        rm -f $TMP_FILE
        exit 1
    fi

    rm -f $TMP_FILE
}

# Check for functions updates
checkCfgVer()
{
    TMP_FILE=$(mktemp -p "" "rmminstall_XXXXXXXXXX")
    curl -s -L "${CFG_URL}" > ${TMP_FILE}
    NEW_VER=$(grep "^CFG_VERSION" "$TMP_FILE" | awk -F'[="]' '{print $3}')

    if [ "${CFG_VERSION}" -ne "${NEW_VER}" ]; then
        printf >&2 "${YELLOW}Old bash function file detected, downloading and replacing with the latest version...${NC}\n"
        wget -q "${CFG_URL}" -O bashfunctions.cfg
        printf >&2 "${YELLOW}File updated! Please re-run .$1${NC}\n"
        rm -f $TMP_FILE
        exit 1
    fi

    rm -f $TMP_FILE
}

# Check for root as user
checkRoot()
{
    if [ $EUID -eq 0 ]; then
        echo -e "${RED}Do NOT run this script as root. Exiting.${NC}"
        exit 1
    fi
}

# Clone primary repo
clonePrimaryRepo()
{
    if [ "$1" == "install" ]; then
        sudo mkdir /rmm
        sudo chown ${USER}:${USER} /rmm
        sudo mkdir -p /var/log/celery
        sudo chown ${USER}:${USER} /var/log/celery
        git clone "$2" /rmm/
    fi
    cd /rmm
    git config user.email "admin@example.com"
    git config user.name "Bob"
    if [ "$1" == "install" ]; then
        git checkout "$3"
    elif [ "$1" == "update" ]; then
        git fetch
        git checkout "$3"
        git reset --hard FETCH_HEAD
        git clean -df
        git pull
    fi
}

# Clone scripts repo
cloneScriptsRepo()
{
    if [[ ! -d ${SCRIPTS_DIR} ]]; then
        sudo mkdir -p ${SCRIPTS_DIR}
        sudo chown ${USER}:${USER} ${SCRIPTS_DIR}
        git clone "$2" ${SCRIPTS_DIR}/
    fi    
    cd ${SCRIPTS_DIR}
    git config user.email "admin@example.com"
    git config user.name "Bob"
    if [ "$1" == "install" ]; then
        git checkout main
    elif [ "$1" == "update" ]; then
        git fetch
        git checkout main
        git reset --hard FETCH_HEAD
        git clean -df
        git pull
    fi
}


###########################
#  System info functions  #
###########################

# Gather OS info
getOSInfo()
{
    osname=$(lsb_release -si); osname=${osname^}
    osname=$(echo "$osname" | tr  '[A-Z]' '[a-z]')
    fullrel=$(lsb_release -sd)
    codename=$(lsb_release -sc)
    relno=$(lsb_release -sr | cut -d. -f1)
    fullrelno=$(lsb_release -sr)
}

# Check OS if not recognised
wutOSThis()
{
    if [ ! "$osname" = "ubuntu" ] && [ ! "$osname" = "debian" ]; then
        osname=$(grep -oP '(?<=^ID=).+' /etc/os-release | tr -d '"')
        osname=${osname^}
    fi
}

# Verify Debian or Ubuntu and version
verifySupportedOS()
{
    if ([ "$osname" = "ubuntu" ] && ([ "$fullrelno" = "20.04" ] || [ "$fullrelno" = "22.04" ])) || ([ "$osname" = "debian" ] && [ $relno -ge 10 ]); then
        echo $fullrel
    else
        echo $fullrel
        echo -e "${RED}Supported versions: Ubuntu 20.04 and 22.04, Debian 10 and 11.${NC}"
        echo -e "${RED}Your system does not appear to be supported.${NC}"
        exit 1
    fi
}

# Check language/locale
checkLocale()
{
    if [[ "$LANG" != *".UTF-8" ]]; then
        printf >&2 "\n${RED}System locale must be ${GREEN}<some language>.UTF-8${RED} not ${YELLOW}${LANG}${NC}\n"
        printf >&2 "${RED}Run the following command and change the default locale to your language of choice${NC}\n\n"
        printf >&2 "${GREEN}sudo dpkg-reconfigure locales${NC}\n\n"
        printf >&2 "${RED}You will need to log out and back in for changes to take effect, then re-run this script.${NC}\n\n"
        exit 1
    fi
}


################
#  User Input  #
################

# Create usernames and passwords
generateUsersAndPass()
{
    manualpass="derp"

    DJANGO_SEKRET=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 80 | head -n 1)
    ADMINURL=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 70 | head -n 1)

    echo " "
    echo -ne "${YELLOW}If you would like to manually enter MeshCentral and Postgresql usernames and passwords${NC}\n"
    echo -ne "${YELLOW}type m for manual at the prompt, or type g to have them randomly generated for you${NC}: "
    read manualpass
    manualpass="$(translateToLowerCase $manualpass)"
    echo " "

    if [ "$manualpass" == "g" ]; then
        MESHPASSWD=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 25 | head -n 1)
        pgusername=$(cat /dev/urandom | tr -dc 'a-z' | fold -w 8 | head -n 1)
        pgpw=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 20 | head -n 1)
        meshusername=$(cat /dev/urandom | tr -dc 'a-z' | fold -w 8 | head -n 1)
    
    elif [ "$manualpass" == "m" ]; then
        passinput=""
        userconfirm="n"
        MESHPASSWD=""
        pgusername=""
        pgpw=""
        meshusername=""

        until [ "$userconfirm" == "y" ]; do
            echo " "
            echo -ne "${YELLOW}Enter the MeshCentral admin username${NC}: "
            read meshusername
            echo " "
            echo -ne "${YELLOW}Is this correct? y or n${NC}: $meshusername "
            read userconfirm
            userconfirm="$(translateToLowerCase $userconfirm)"
            if [ "$userconfirm" != "y" ]; then
                derpDerp;
            else
                echo -e "${YELLOW}Confirmed${NC}"
            fi
        done
        userconfirm="n"

        until [ "$passinput" == "$MESHPASSWD" ]; do
            read -s -p "Enter the MeshCentral admin password: " MESHPASSWD
            echo " "
            read -s -p "Re-enter the MeshCentral admin password: " passinput
            if [ "$passinput" != "$MESHPASSWD" ]; then
                echo " "
                echo -e "${YELLOW}Passwords do not match.${NC}"
                derpDerp;
            else
                echo -e "${YELLOW}Confirmed${NC}"
            fi
        done

        until [ "$userconfirm" == "y" ]; do
            echo " "
            echo -ne "${YELLOW}Enter the Postgresql admin username${NC}: "
            read pgusername
            echo " "
            echo -ne "${YELLOW}Is this correct? y or n${NC}: $pgusername "
            read userconfirm
            userconfirm="$(translateToLowerCase $userconfirm)"
            if [ "$userconfirm" != "y" ]; then
                derpDerp;
            else
                echo -e "${YELLOW}Confirmed${NC}"
            fi
        done
        userconfirm="n"

        until [ "$passinput" == "$pgpw" ]; do
            read -s -p "Enter the Postgresql admin password: " pgpw
            echo " "
            read -s -p "Re-enter the Postgresql admin password: " passinput
            if [ "$passinput" != "$pgpw" ]; then
                echo " "
                echo -e "${YELLOW}Passwords do not match.${NC}"
                derpDerp;
            else
                echo -e "${YELLOW}Confirmed${NC}"
            fi
        done
    else
        derpDerp;
    fi
}

# Get host and domain info
getHostAndDomainInfo()
{
    hostsconfirm="n"

    until [ $hostsconfirm == "y" ]; do
        rootdomain="none"
        letsemail="none"
        while [[ $rootdomain != *[.]* ]]; do
            echo -ne "${YELLOW}Enter the root domain (e.g. example.com or example.co.uk)${NC}: "
            read rootdomain
            rootdomain="$(translateToLowerCase $rootdomain)"
            echo " "
            if [[ $rootdomain != *[.]* ]]; then
                derpDerp;
            fi
        done

        echo -ne "${YELLOW}Enter the hostname for the backend (e.g. api)${NC}: "
        read rmmhost
        rmmhost="$(translateToLowerCase $rmmhost)"
        echo " "

        echo -ne "${YELLOW}Enter the hostname for the frontend (e.g. rmm)${NC}: "
        read frontendhost
        frontendhost="$(translateToLowerCase $frontendhost)"
        echo " "

        echo -ne "${YELLOW}Enter the hostname for meshcentral (e.g. mesh)${NC}: "
        read meshhost
        meshhost="$(translateToLowerCase $meshhost)"
        echo " "

        while [[ $letsemail != *[@]*[.]* ]]; do
            echo -ne "${YELLOW}Enter a valid e-mail address for django, meshcentral, and letsencrypt${NC}: "
            read letsemail 
            letsemail="$(translateToLowerCase $letsemail)"
            echo " "
            if [[ $letsemail != *[@]*[.]* ]]; then
                derpDerp;
            fi
        done

        echo " "
        echo "${YELLOW}root domain${NC}: $rootdomain"
        echo "${YELLOW}backend${NC}: $rmmhost.$rootdomain"
        echo "${YELLOW}frontend${NC}: $frontendhost.$rootdomain"
        echo "${YELLOW}meshcentral${NC}: $meshhost.$rootdomain"
        echo "${YELLOW}e-mail address${NC}: $letsemail"
        echo " "
        echo -ne "${YELLOW}Is this correct? y or n${NC}: "
        read hostsconfirm
        hostsconfirm="$(translateToLowerCase $hostsconfirm)"
        if [ "$hostsconfirm" != "y" ]; then
            derpDerp;
        else
            echo -e "${YELLOW}Confirmed${NC}"
        fi

    done

    rmmdomain="$rmmhost.$rootdomain"
    meshdomain="$meshhost.$rootdomain"
    frontenddomain="$frontendhost.$rootdomain"
}


#######################
#  Network Functions  #
#######################

# Check hosts file, add hosts
configHosts()
{
    # If server is behind NAT we need to add the 3 subdomains to the host file
    # so that nginx can properly route between the frontend, backend and meshcentral
    # EDIT 8-29-2020
    # running this even if server is __not__ behind NAT just to make DNS resolving faster
    # this also allows the install script to properly finish even if DNS has not fully propagated
    CHECK_HOSTS=$(grep 127.0.1.1 /etc/hosts | grep "$rmmdomain" | grep "$meshdomain" | grep "$frontenddomain")
    HAS_11=$(grep 127.0.1.1 /etc/hosts)

    if ! [[ $CHECK_HOSTS ]]; then
        print_green 'Adding subdomains to hosts file'
        if [[ $HAS_11 ]]; then
            sudo sed -i "/127.0.1.1/s/$/ ${rmmdomain} ${frontenddomain} ${meshdomain}/" /etc/hosts
        else
            echo "127.0.1.1 ${rmmdomain} ${frontenddomain} ${meshdomain}" | sudo tee --append /etc/hosts > /dev/null
        fi
    fi

    BEHIND_NAT=false
    IPV4=$(ip -4 addr | sed -ne 's|^.* inet \([^/]*\)/.* scope global.*$|\1|p' | head -1)
    if echo "$IPV4" | grep -qE '^(10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.|192\.168)'; then
        BEHIND_NAT=true
    fi
}


#######################
#  Install Functions  #
#######################

# Install script prereqs
installPreReqs()
{
    sudo apt update && sudo apt install -y curl wget dirmngr gnupg lsb-release ncurses-base ncurses-bin ncurses-doc ncurses-examples ncurses-term dialog libncurses5 libncursesw5 libncurses5-dev libncursesw5-dev
}

# Install remaining prereqs
installAdditionalPreReqs()
{
    sudo apt install -y software-properties-common openssl ca-certificates apt-transport-https gcc g++ make build-essential zlib1g-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libsqlite3-dev libbz2-dev git
}

# Configure repos for stuff
setInstallRepos()
{
    # There is no Jammy repo yet so use Focal for Ubuntu 22.04
    if ([ "$osname" = "ubuntu" ] && [ "$fullrelno" = "20.04" ]); then
        mongodb_repo="deb [arch=amd64] https://repo.mongodb.org/apt/$osname $codename/mongodb-org/4.4 multiverse"
    elif ([ "$osname" = "ubuntu" ] && [ "$fullrelno" = "22.04" ]); then
        codename="focal"
        mongodb_repo="deb [arch=amd64] https://repo.mongodb.org/apt/$osname $codename/mongodb-org/4.4 multiverse"
    # There is no bullseye repo yet for mongo so just use Buster on Debian 11
    elif ([ "$osname" = "debian" ] && [ $relno -eq 10 ]); then
        mongodb_repo="deb [arch=amd64] https://repo.mongodb.org/apt/$osname $codename/mongodb-org/4.4 main"
    else
        codename="buster"
        mongodb_repo="deb [arch=amd64] https://repo.mongodb.org/apt/$osname $codename/mongodb-org/4.4 main"
    fi

    postgresql_repo="deb [arch=amd64] https://apt.postgresql.org/pub/repos/apt/ $codename-pgdg main"
}

# Install MongoDB
installMongo()
{
    wget -qO - https://www.mongodb.org/static/pgp/server-4.4.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/mongo.gpg > /dev/null
    echo "$mongodb_repo" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.4.list
    sudo apt update && sudo apt install -y mongodb-org
    sudo systemctl enable mongod
    sudo systemctl restart mongod
    sleep 5
}

# Install NodeJS
installNodeJS()
{
    if [ "$1" == "update" ]; then
        HAS_NODE16=$(node --version | grep v16)
        if ! [[ $HAS_NODE16 ]]; then
            printf >&2 "${GREEN}Updating NodeJS to v16${NC}\n"
            rm -rf /rmm/web/node_modules
            sudo systemctl stop meshcentral
            sudo apt remove -y nodejs
            sudo rm -rf /usr/lib/node_modules
        fi
    fi
    curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -
    sudo apt update && sudo apt install -y nodejs
    sudo npm install -g npm
    if [ "$1" == "update" ]; then
        sudo chown ${USER}:${USER} -R /meshcentral
        cd /meshcentral
        rm -rf node_modules/
        npm install meshcentral@${LATEST_MESH_VER}
        sudo systemctl start meshcentral
    fi
}

# Install Redis
installRedis()
{
    sudo apt install -y redis
}

# Install Python
installPython()
{
    if [ "$1" == "update" ]; then
        HAS_PY310=$(python3.10 --version | grep ${PYTHON_VER})
        if ! [[ $HAS_PY310 ]]; then
            printf >&2 "${GREEN}Updating to ${PYTHON_VER}${NC}\n"
        fi
    fi

    if [ "$INSTALL_TYPE" == "devinstall" ]; then
        echo -e "${GREEN}Python already installed${NC}"
    else
        numprocs=$(nproc)
        cd ~
        wget https://www.python.org/ftp/python/${PYTHON_VER}/Python-${PYTHON_VER}.tgz
        tar -xf Python-${PYTHON_VER}.tgz
        cd Python-${PYTHON_VER}
        ./configure --enable-optimizations
        make -j $numprocs
        sudo make altinstall
        cd ~
        sudo rm -rf Python-${PYTHON_VER} Python-${PYTHON_VER}.tgz
        if [ "$INSTALL_TYPE" == "devprep" ]; then
            print_green 'All Prereqs installed'
            exit
        fi
    fi
}

# Install Postgresql
installPostgresql()
{
    echo "$postgresql_repo" | sudo tee /etc/apt/sources.list.d/pgdg.list
    wget -qO - https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/postgresql.gpg > /dev/null
    sudo apt update && sudo apt install -y postgresql-14
    sleep 2
    sudo systemctl enable postgresql
    sudo systemctl restart postgresql
    sleep 5
}

# Install NATS
installNats()
{
    if [ "$1" == "update" ]; then
        HAS_LATEST_NATS=$(/usr/local/bin/nats-server -version | grep "${NATS_SERVER_VER}")
        if ! [[ $HAS_LATEST_NATS ]]; then
            printf >&2 "${GREEN}Updating nats to v${NATS_SERVER_VER}${NC}\n"
        fi
    fi
    if [ "$1" == "install" ]; then
        NATS_SERVER_VER=$(grep "^NATS_SERVER_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')
    fi
    nats_tmp=$(mktemp -d -t nats-XXXXXXXXXX)
    wget -q https://github.com/nats-io/nats-server/releases/download/v${NATS_SERVER_VER}/nats-server-v${NATS_SERVER_VER}-linux-amd64.tar.gz -P ${nats_tmp}
    tar -xzf ${nats_tmp}/nats-server-v${NATS_SERVER_VER}-linux-amd64.tar.gz -C ${nats_tmp}
    if [ "$1" == "update" ]; then
        sudo rm -f /usr/local/bin/nats-server
    fi
    sudo mv ${nats_tmp}/nats-server-v${NATS_SERVER_VER}-linux-amd64/nats-server /usr/local/bin/
    sudo chmod +x /usr/local/bin/nats-server
    sudo chown ${USER}:${USER} /usr/local/bin/nats-server
    rm -rf ${nats_tmp}
}

# Install frontend
installFrontEnd()
{
    if [ "$1" == "update" ]; then
        if [ -d /rmm/web ]; then
            rm -rf /rmm/web
        fi

        if [ ! -d /var/www/rmm ]; then
            sudo mkdir -p /var/www/rmm
        fi
    fi

    webtar="trmm-web-v${WEB_VERSION}.tar.gz"
    wget -q "$2" -O /tmp/${webtar}
    
    if [ "$1" == "update" ]; then
        sudo rm -rf /var/www/rmm/dist
    else
        sudo mkdir -p /var/www/rmm
    fi
    sudo tar -xzf /tmp/${webtar} -C /var/www/rmm
    echo "window._env_ = {PROD_URL: \"https://${rmmdomain}\"}" | sudo tee /var/www/rmm/dist/env-config.js > /dev/null
    sudo chown www-data:www-data -R /var/www/rmm/dist
    rm -f /tmp/${webtar}
}

# Install Nginx
installNginx()
{
    if [ "$1" == "install" ]; then
	    sudo apt install -y nginx
	    sudo systemctl stop nginx
        sudo sed -i 's/worker_connections.*/worker_connections 2048;/g' /etc/nginx/nginx.conf
        sudo sed -i 's/# server_names_hash_bucket_size.*/server_names_hash_bucket_size 64;/g' /etc/nginx/nginx.conf
    elif [ "$1" == "updatepart1" ]; then
        ### Check Nginx config
        if ! sudo nginx -t > /dev/null 2>&1; then
            sudo nginx -t
            echo -ne "\n"
            echo -ne "${RED}You have syntax errors in your nginx configs. See errors above. Please fix them and re-run this script.${NC}\n"
            echo -ne "${RED}Aborting...${NC}\n"
            exit 1
        fi
    elif [ "$1" == "updatepart2" ]; then
        CHECK_NGINX_WORKER_CONN=$(grep "worker_connections 2048" /etc/nginx/nginx.conf)
        if ! [[ $CHECK_NGINX_WORKER_CONN ]]; then
            printf >&2 "${GREEN}Changing nginx worker connections to 2048${NC}\n"
            sudo sed -i 's/worker_connections.*/worker_connections 2048;/g' /etc/nginx/nginx.conf
        fi
        sudo sed -i 's/# server_names_hash_bucket_size.*/server_names_hash_bucket_size 64;/g' /etc/nginx/nginx.conf
    else
        return
    fi
}

# Install NATS Api
installNatsApi()
{
    sudo cp /rmm/natsapi/bin/nats-api /usr/local/bin
    sudo chown ${USER}:${USER} /usr/local/bin/nats-api
    sudo chmod +x /usr/local/bin/nats-api
}

# Install MeshCentral
installMeshCentral()
{
    MESH_VER=$(grep "^MESH_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')

    if [ "$1" == "install" ]; then
        sudo mkdir -p /meshcentral/meshcentral-data
    elif [ "$1" == "restore" ]; then
        sudo tar -xzf $tmp_dir/meshcentral/mesh.tar.gz -C /
    fi
    sudo chown ${USER}:${USER} -R /meshcentral
    cd /meshcentral
    npm install meshcentral@${MESH_VER}
    sudo chown ${USER}:${USER} -R /meshcentral
}


########################
#  Database Functions  #
########################

# Postgres DB creation
createPGDB()
{
	sudo -u postgres psql -c "CREATE DATABASE tacticalrmm"
	sudo -u postgres psql -c "CREATE USER ${pgusername} WITH PASSWORD '${pgpw}'"
	sudo -u postgres psql -c "ALTER ROLE ${pgusername} SET client_encoding TO 'utf8'"
	sudo -u postgres psql -c "ALTER ROLE ${pgusername} SET default_transaction_isolation TO 'read committed'"
	sudo -u postgres psql -c "ALTER ROLE ${pgusername} SET timezone TO 'UTC'"
	sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE tacticalrmm TO ${pgusername}"
}


###########################
#  Certificate Functions  #
###########################

# Install Certbot and get initial certs
installCertbot()
{
    sudo apt install -y certbot
    if [ "$1" == "restore" ]; then
        return
    fi

    if [ "$INSTALL_TYPE" == "devinstall" ]; then
        echo -e "${GREEN}Wildcard cert should be in place${NC}"
    else
        print_green 'Getting wildcard cert'

        sudo certbot certonly --manual -d *.${rootdomain} --agree-tos --no-bootstrap --preferred-challenges dns -m ${letsemail} --no-eff-email
        while [[ $? -ne 0 ]]; do
            sudo certbot certonly --manual -d *.${rootdomain} --agree-tos --no-bootstrap --preferred-challenges dns -m ${letsemail} --no-eff-email
        done

        CERT_PRIV_KEY=/etc/letsencrypt/live/${rootdomain}/privkey.pem
        CERT_PUB_KEY=/etc/letsencrypt/live/${rootdomain}/fullchain.pem

        sudo chown ${USER}:${USER} -R /etc/letsencrypt
        sudo chmod 775 -R /etc/letsencrypt
    fi
}


#######################################
#  Config file and service functions  #
#######################################

# Generate mesh configuration
createMeshConfig()
{
    meshcfg="$(cat << EOF
    {
    "settings": {
        "Cert": "${meshdomain}",
        "MongoDb": "mongodb://127.0.0.1:27017",
        "MongoDbName": "meshcentral",
        "WANonly": true,
        "Minify": 1,
        "Port": 4443,
        "AgentAliasPort": 443,
        "AliasPort": 443,
        "AllowLoginToken": true,
        "AllowFraming": true,
        "_AgentPing": 60,
        "AgentPong": 300,
        "AllowHighQualityDesktop": true,
        "TlsOffload": "127.0.0.1",
        "agentCoreDump": false,
        "Compression": true,
        "WsCompression": true,
        "AgentWsCompression": true,
        "MaxInvalidLogin": { "time": 5, "count": 5, "coolofftime": 30 }
    },
    "domains": {
        "": {
            "Title": "Tactical RMM",
            "Title2": "Tactical RMM",
            "NewAccounts": false,
            "CertUrl": "https://${meshdomain}/",
            "GeoLocation": true,
            "CookieIpCheck": false,
            "mstsc": true
            }
        }
    }
    EOF
    )"
    echo "${meshcfg}" > /meshcentral/meshcentral-data/config.json
}

# Generate local settings file
createLocalSettings()
{
    localvars="$(cat << EOF
    SECRET_KEY = "${DJANGO_SEKRET}"

    DEBUG = False

    ALLOWED_HOSTS = ['${rmmdomain}']

    ADMIN_URL = "${ADMINURL}/"

    CORS_ORIGIN_WHITELIST = [
        "https://${frontenddomain}"
    ]

    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.postgresql',
            'NAME': 'tacticalrmm',
            'USER': '${pgusername}',
            'PASSWORD': '${pgpw}',
            'HOST': 'localhost',
            'PORT': '5432',
        }
    }

    MESH_USERNAME = "${meshusername}"
    MESH_SITE = "https://${meshdomain}"
    REDIS_HOST    = "localhost"
    ADMIN_ENABLED = True
    EOF
    )"
    echo "${localvars}" > /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
}

# Backend configuration
configureBackend()
{
    SETUPTOOLS_VER=$(grep "^SETUPTOOLS_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')
    WHEEL_VER=$(grep "^WHEEL_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')

    if [ "$1" == "update" ]; then
        CHECK_CELERY_CONFIG=$(grep "autoscale=20,2" /etc/conf.d/celery.conf)
        if ! [[ $CHECK_CELERY_CONFIG ]]; then
            sed -i 's/CELERYD_OPTS=.*/CELERYD_OPTS="--time-limit=86400 --autoscale=20,2"/g' /etc/conf.d/celery.conf
        fi
        CHECK_ADMIN_ENABLED=$(grep ADMIN_ENABLED /rmm/api/tacticalrmm/tacticalrmm/local_settings.py)
        if ! [[ $CHECK_ADMIN_ENABLED ]]; then
            adminenabled="$(cat << EOF
            ADMIN_ENABLED = False
            EOF
            )"
            echo "${adminenabled}" | tee --append /rmm/api/tacticalrmm/tacticalrmm/local_settings.py > /dev/null
        fi
        sudo cp /rmm/natsapi/bin/nats-api /usr/local/bin
        sudo chown ${USER}:${USER} /usr/local/bin/nats-api
        sudo chmod +x /usr/local/bin/nats-api
        if [[ "${CURRENT_PIP_VER}" != "${LATEST_PIP_VER}" ]] || [[ "$UPDATE_TYPE" == "forced" ]]; then
            rm -rf /rmm/api/env
        fi
    fi

    if [[ "${CURRENT_PIP_VER}" == "${LATEST_PIP_VER}" ]] && [[ "$UPDATE_TYPE" == "standard" ]]; then
        source /rmm/api/env/bin/activate
        cd /rmm/api/tacticalrmm
        pip install -r /rmm/api/tacticalrmm/requirements.txt
    else
        cd /rmm/api
        python3.10 -m venv env
        source /rmm/api/env/bin/activate
        cd /rmm/api/tacticalrmm
        pip install --no-cache-dir --upgrade pip
        pip install --no-cache-dir setuptools==${SETUPTOOLS_VER} wheel==${WHEEL_VER}
        pip install --no-cache-dir -r /rmm/api/tacticalrmm/requirements.txt
    fi

    if [ "$1" == "update" ]; then
        python manage.py pre_update_tasks
        celery -A tacticalrmm purge -f
        python manage.py migrate
        python manage.py delete_tokens
        python manage.py collectstatic --no-input
        python manage.py reload_nats
        python manage.py load_chocos
        python manage.py create_installer_user
        python manage.py create_natsapi_conf
        python manage.py post_update_tasks
        rmmdomain=$(python manage.py get_config api)
        WEB_VERSION=$(python manage.py get_config webversion)
        deactivate
    elif [ "$1" == "restore" ]; then
        python manage.py migrate
        python manage.py collectstatic --no-input
        python manage.py create_natsapi_conf
        python manage.py reload_nats
        python manage.py post_update_tasks
        rmmdomain=$(python manage.py get_config api)
        WEB_VERSION=$(python manage.py get_config webversion)
        deactivate
    else
        python manage.py migrate
        python manage.py collectstatic --no-input
        python manage.py create_natsapi_conf
        python manage.py load_chocos
        python manage.py load_community_scripts
        WEB_VERSION=$(python manage.py get_config webversion)
        printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
        printf >&2 "\n"
        printf >&2 "${YELLOW}Please create your login for the RMM website and django admin${NC}\n"
        printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
        printf >&2 "\n"
        echo -ne "Username: "
        read djangousername
        python manage.py createsuperuser --username ${djangousername} --email ${letsemail}
        python manage.py create_installer_user
        RANDBASE=$(python manage.py generate_totp)
        cls;
        python manage.py generate_barcode ${RANDBASE} ${djangousername} ${frontenddomain}
        deactivate
        read -n 1 -s -r -p "Press any key to continue..."
    fi
}

# Set uwsgi procs
setUwsgiProcs()
{
    uwsgiprocs=4
    if [[ "$numprocs" == "1" ]]; then
        uwsgiprocs=2
    else
        uwsgiprocs=$numprocs
    fi
}

# Create UWSGI config
createUwsgiConf()
{
    uwsgini="$(cat << EOF
    [uwsgi]
    chdir = /rmm/api/tacticalrmm
    module = tacticalrmm.wsgi
    home = /rmm/api/env
    master = true
    processes = ${uwsgiprocs}
    threads = ${uwsgiprocs}
    enable-threads = true
    socket = /rmm/api/tacticalrmm/tacticalrmm.sock
    harakiri = 300
    chmod-socket = 660
    buffer-size = 65535
    vacuum = true
    die-on-term = true
    max-requests = 500
    disable-logging = true
    EOF
    )"
    echo "${uwsgini}" > /rmm/api/tacticalrmm/app.ini
}

# Create UWSGI service
createUwsgiService()
{
    rmmservice="$(cat << EOF
    [Unit]
    Description=tacticalrmm uwsgi daemon
    After=network.target postgresql.service

    [Service]
    User=${USER}
    Group=www-data
    WorkingDirectory=/rmm/api/tacticalrmm
    Environment="PATH=/rmm/api/env/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    ExecStart=/rmm/api/env/bin/uwsgi --ini app.ini
    Restart=always
    RestartSec=10s

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${rmmservice}" | sudo tee /etc/systemd/system/rmm.service > /dev/null
}

# Create Daphne service
createDaphneService()
{
    daphneservice="$(cat << EOF
    [Unit]
    Description=django channels daemon
    After=network.target

    [Service]
    User=${USER}
    Group=www-data
    WorkingDirectory=/rmm/api/tacticalrmm
    Environment="PATH=/rmm/api/env/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    ExecStart=/rmm/api/env/bin/daphne -u /rmm/daphne.sock tacticalrmm.asgi:application
    Restart=always
    RestartSec=3s

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${daphneservice}" | sudo tee /etc/systemd/system/daphne.service > /dev/null
}

# Create NATS service
createNatsService()
{
    natsservice="$(cat << EOF
    [Unit]
    Description=NATS Server
    After=network.target

    [Service]
    PrivateTmp=true
    Type=simple
    ExecStart=/usr/local/bin/nats-server -c /rmm/api/tacticalrmm/nats-rmm.conf
    ExecReload=/usr/bin/kill -s HUP \$MAINPID
    ExecStop=/usr/bin/kill -s SIGINT \$MAINPID
    User=${USER}
    Group=www-data
    Restart=always
    RestartSec=5s
    LimitNOFILE=1000000

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${natsservice}" | sudo tee /etc/systemd/system/nats.service > /dev/null
}

# Create NATS service
createNatsApiService()
{
    natsapi="$(cat << EOF
    [Unit]
    Description=TacticalRMM Nats Api v1
    After=nats.service

    [Service]
    Type=simple
    ExecStart=/usr/local/bin/nats-api
    User=${USER}
    Group=${USER}
    Restart=always
    RestartSec=5s

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${natsapi}" | sudo tee /etc/systemd/system/nats-api.service > /dev/null
}

# Create backend nginx conf
createBackendNginxConf()
{
    nginxrmm="$(cat << EOF
    server_tokens off;

    upstream tacticalrmm {
        server unix:////rmm/api/tacticalrmm/tacticalrmm.sock;
    }

    map \$http_user_agent \$ignore_ua {
        "~python-requests.*" 0;
        "~go-resty.*" 0;
        default 1;
    }

    server {
        listen 80;
        listen [::]:80;
        server_name ${rmmdomain};
        return 301 https://\$server_name\$request_uri;
    }

    server {
        listen 443 ssl;
        listen [::]:443 ssl;
        server_name ${rmmdomain};
        client_max_body_size 300M;
        access_log /rmm/api/tacticalrmm/tacticalrmm/private/log/access.log combined if=\$ignore_ua;
        error_log /rmm/api/tacticalrmm/tacticalrmm/private/log/error.log;
        ssl_certificate ${CERT_PUB_KEY};
        ssl_certificate_key ${CERT_PRIV_KEY};
    
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers EECDH+AESGCM:EDH+AESGCM;
        ssl_ecdh_curve secp384r1;
        ssl_stapling on;
        ssl_stapling_verify on;
        add_header X-Content-Type-Options nosniff;
    
        location /static/ {
            root /rmm/api/tacticalrmm;
        }

        location /private/ {
            internal;
            add_header "Access-Control-Allow-Origin" "https://${frontenddomain}";
            alias /rmm/api/tacticalrmm/tacticalrmm/private/;
        }

        location ~ ^/ws/ {
            proxy_pass http://unix:/rmm/daphne.sock;

            proxy_http_version 1.1;
            proxy_set_header Upgrade \$http_upgrade;
            proxy_set_header Connection "upgrade";

            proxy_redirect     off;
            proxy_set_header   Host \$host;
            proxy_set_header   X-Real-IP \$remote_addr;
            proxy_set_header   X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Host \$server_name;
        }

        location / {
            uwsgi_pass  tacticalrmm;
            include     /etc/nginx/uwsgi_params;
            uwsgi_read_timeout 300s;
            uwsgi_ignore_client_abort on;
        }
    }
    EOF
    )"
    echo "${nginxrmm}" | sudo tee /etc/nginx/sites-available/rmm.conf > /dev/null
}

# Create Mesh nginx conf
createMeshNginxConf()
{
    nginxmesh="$(cat << EOF
    server {
        listen 80;
        listen [::]:80;
        server_name ${meshdomain};
        return 301 https://\$server_name\$request_uri;
    }

    server {
        listen 443 ssl;
        listen [::]:443 ssl;
        proxy_send_timeout 330s;
        proxy_read_timeout 330s;
        server_name ${meshdomain};
        ssl_certificate ${CERT_PUB_KEY};
        ssl_certificate_key ${CERT_PRIV_KEY};

        ssl_session_cache shared:WEBSSL:10m;

        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers EECDH+AESGCM:EDH+AESGCM;
        ssl_ecdh_curve secp384r1;
        ssl_stapling on;
        ssl_stapling_verify on;
        add_header X-Content-Type-Options nosniff;

        location / {
            proxy_pass http://127.0.0.1:4443/;
            proxy_http_version 1.1;

            proxy_set_header Host \$host;
            proxy_set_header Upgrade \$http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header X-Forwarded-Host \$host:\$server_port;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }
    }
    EOF
    )"
    echo "${nginxmesh}" | sudo tee /etc/nginx/sites-available/meshcentral.conf > /dev/null
}

# Create Celery service
createCeleryService()
{
    celeryservice="$(cat << EOF
    [Unit]
    Description=Celery Service V2
    After=network.target redis-server.service postgresql.service

    [Service]
    Type=forking
    User=${USER}
    Group=${USER}
    EnvironmentFile=/etc/conf.d/celery.conf
    WorkingDirectory=/rmm/api/tacticalrmm
    ExecStart=/bin/sh -c '\${CELERY_BIN} -A \$CELERY_APP multi start \$CELERYD_NODES --pidfile=\${CELERYD_PID_FILE} --logfile=\${CELERYD_LOG_FILE} --loglevel="\${CELERYD_LOG_LEVEL}" \$CELERYD_OPTS'
    ExecStop=/bin/sh -c '\${CELERY_BIN} multi stopwait \$CELERYD_NODES --pidfile=\${CELERYD_PID_FILE} --loglevel="\${CELERYD_LOG_LEVEL}"'
    ExecReload=/bin/sh -c '\${CELERY_BIN} -A \$CELERY_APP multi restart \$CELERYD_NODES --pidfile=\${CELERYD_PID_FILE} --logfile=\${CELERYD_LOG_FILE} --loglevel="\${CELERYD_LOG_LEVEL}" \$CELERYD_OPTS'
    Restart=always
    RestartSec=10s

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${celeryservice}" | sudo tee /etc/systemd/system/celery.service > /dev/null
}

# Create Celery config
createCeleryConf()
{
    celeryconf="$(cat << EOF
    CELERYD_NODES="w1"

    CELERY_BIN="/rmm/api/env/bin/celery"

    CELERY_APP="tacticalrmm"

    CELERYD_MULTI="multi"

    CELERYD_OPTS="--time-limit=86400 --autoscale=20,2"

    CELERYD_PID_FILE="/rmm/api/tacticalrmm/%n.pid"
    CELERYD_LOG_FILE="/var/log/celery/%n%I.log"
    CELERYD_LOG_LEVEL="ERROR"

    CELERYBEAT_PID_FILE="/rmm/api/tacticalrmm/beat.pid"
    CELERYBEAT_LOG_FILE="/var/log/celery/beat.log"
    EOF
    )"
    echo "${celeryconf}" | sudo tee /etc/conf.d/celery.conf > /dev/null
}

# Create CeleryBeat service
createCeleryBeatService()
{
    celerybeatservice="$(cat << EOF
    [Unit]
    Description=Celery Beat Service V2
    After=network.target redis-server.service postgresql.service

    [Service]
    Type=simple
    User=${USER}
    Group=${USER}
    EnvironmentFile=/etc/conf.d/celery.conf
    WorkingDirectory=/rmm/api/tacticalrmm
    ExecStart=/bin/sh -c '\${CELERY_BIN} -A \${CELERY_APP} beat --pidfile=\${CELERYBEAT_PID_FILE} --logfile=\${CELERYBEAT_LOG_FILE} --loglevel=\${CELERYD_LOG_LEVEL}'
    Restart=always
    RestartSec=10s

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${celerybeatservice}" | sudo tee /etc/systemd/system/celerybeat.service > /dev/null
}

# Create MeshCentral service
createMeshCentralService()
{
    meshservice="$(cat << EOF
    [Unit]
    Description=MeshCentral Server
    After=network.target mongod.service nginx.service
    [Service]
    Type=simple
    LimitNOFILE=1000000
    ExecStart=/usr/bin/node node_modules/meshcentral
    Environment=NODE_ENV=production
    WorkingDirectory=/meshcentral
    User=${USER}
    Group=${USER}
    Restart=always
    RestartSec=10s

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${meshservice}" | sudo tee /etc/systemd/system/meshcentral.service > /dev/null
}

# Create Frontend Nginx config
createFrontendNginxConf()
{
    nginxfrontend="$(cat << EOF
    server {
        server_name ${frontenddomain};
        charset utf-8;
        location / {
            root /var/www/rmm/dist;
            try_files \$uri \$uri/ /index.html;
            add_header Cache-Control "no-store, no-cache, must-revalidate";
            add_header Pragma "no-cache";
        }
        error_log  /var/log/nginx/frontend-error.log;
        access_log /var/log/nginx/frontend-access.log;

        listen 443 ssl;
        listen [::]:443 ssl;
        ssl_certificate ${CERT_PUB_KEY};
        ssl_certificate_key ${CERT_PRIV_KEY};
    
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers EECDH+AESGCM:EDH+AESGCM;
        ssl_ecdh_curve secp384r1;
        ssl_stapling on;
        ssl_stapling_verify on;
        add_header X-Content-Type-Options nosniff;
    }

    server {
        if (\$host = ${frontenddomain}) {
            return 301 https://\$host\$request_uri;
        }

        listen 80;
        listen [::]:80;
        server_name ${frontenddomain};
        return 404;
    }
    EOF
    )"
    echo "${nginxfrontend}" | sudo tee /etc/nginx/sites-available/frontend.conf > /dev/null
}

# Enable MeshCentral service
enableMeshService()
{
    sudo systemctl enable meshcentral
    sudo systemctl restart meshcentral
    sleep 3

    # The first time we start meshcentral, it will need some time to generate certs and install plugins.
    # This will take anywhere from a few seconds to a few minutes depending on the server's hardware
    # We will know it's ready once the last line of the systemd service stdout is 'MeshCentral HTTP server running on port.....'
    while ! [[ $CHECK_MESH_READY ]]; do
        CHECK_MESH_READY=$(sudo journalctl -u meshcentral.service -b --no-pager | grep "MeshCentral HTTP server running on port")
        echo -ne "${GREEN}Mesh Central not ready yet...${NC}\n"
        sleep 3
    done
}

# Generate Mesh Token
generateMeshToken()
{
    MESHTOKENKEY="$(node /meshcentral/node_modules/meshcentral --logintokenkey)"

    meshtoken="$(cat << EOF
    MESH_TOKEN_KEY = "${MESHTOKENKEY}"
    EOF
    )"
    echo "${meshtoken}" | tee --append /rmm/api/tacticalrmm/tacticalrmm/local_settings.py > /dev/null
}

# Configure Mesh user and group, restart service
configMeshUserGroup()
{
    sudo systemctl stop meshcentral
    sleep 1
    cd /meshcentral

    node node_modules/meshcentral --createaccount ${meshusername} --pass ${MESHPASSWD} --email ${letsemail}
    sleep 1
    node node_modules/meshcentral --adminaccount ${meshusername}

    sudo systemctl start meshcentral
    sleep 5

    while ! [[ $CHECK_MESH_READY2 ]]; do
        CHECK_MESH_READY2=$(sudo journalctl -u meshcentral.service -b --no-pager | grep "MeshCentral HTTP server running on port")
        echo -ne "${GREEN}Mesh Central not ready yet...${NC}\n"
        sleep 3
    done

    node node_modules/meshcentral/meshctrl.js --url wss://${meshdomain} --loginuser ${meshusername} --loginpass ${MESHPASSWD} AddDeviceGroup --name TacticalRMM
    sleep 1
}

# Configure and enable NATS service
enableNatsService()
{
    sudo systemctl enable nats.service
    cd /rmm/api/tacticalrmm
    source /rmm/api/env/bin/activate
    python manage.py initial_db_setup
    python manage.py reload_nats
    deactivate
    sudo systemctl start nats.service

    sleep 1
    sudo systemctl enable nats-api.service
    sudo systemctl start nats-api.service
}


###########################################
#  Update and Restore specific functions  #
###########################################

# Check that user is same as during install
checkSameUser()
{
    strip="User="
    if [ "$1" == "update" ]; then
        ORIGUSER=$(grep ${strip} /etc/systemd/system/rmm.service | sed -e "s/^${strip}//")
    elif [ "$1" == "restore" ]; then
        ORIGUSER=$(grep ${strip} $tmp_dir/systemd/rmm.service | sed -e "s/^${strip}//")
    fi
    if [ "$ORIGUSER" != "$USER" ]; then
        printf >&2 "${RED}ERROR: You must run this update script from the same user account used during install: ${GREEN}${ORIGUSER}${NC}\n"
        if [ "$1" == "restore" ]; then
            rm -rf $tmp_dir
        fi
        exit 1
    fi
}

# Check if T-RMM update is necessary
checkIfUpdate()
{
    TMP_SETTINGS=$(mktemp -p "" "rmmsettings_XXXXXXXXXX")
    curl -s -L "${LATEST_SETTINGS_URL}" > ${TMP_SETTINGS}

    LATEST_TRMM_VER=$(grep "^TRMM_VERSION" "$TMP_SETTINGS" | awk -F'[= "]' '{print $5}')
    CURRENT_TRMM_VER=$(grep "^TRMM_VERSION" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')

    if [[ "${CURRENT_TRMM_VER}" == "${LATEST_TRMM_VER}" ]] && [[ "$UPDATE_TYPE" == "standard" ]]; then
        printf >&2 "${GREEN}Already on latest version. Current version: ${CURRENT_TRMM_VER} Latest version: ${LATEST_TRMM_VER}${NC}\n"
        rm -f $TMP_SETTINGS
        exit 0
    fi
}

# Get current versions of necessary included apps
checkAdditionalAppsVers()
{
    LATEST_MESH_VER=$(grep "^MESH_VER" "$TMP_SETTINGS" | awk -F'[= "]' '{print $5}')
    LATEST_PIP_VER=$(grep "^PIP_VER" "$TMP_SETTINGS" | awk -F'[= "]' '{print $5}')
    NATS_SERVER_VER=$(grep "^NATS_SERVER_VER" "$TMP_SETTINGS" | awk -F'[= "]' '{print $5}')
    CURRENT_PIP_VER=$(grep "^PIP_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')
}

# Check CHECK_NATS_LIMITNOFILE, whatever that means
checkNatsLimitNoFile()
{
    CHECK_NATS_LIMITNOFILE=$(grep LimitNOFILE /etc/systemd/system/nats.service)
    if ! [[ $CHECK_NATS_LIMITNOFILE ]]; then

        sudo rm -f /etc/systemd/system/nats.service
        createNatsService;
        sudo systemctl daemon-reload
    fi
}

# Disable Redis append only
turnOffRedisAppendOnly()
{
    printf >&2 "${GREEN}Turning off redis aof${NC}\n"
    sudo redis-cli config set appendonly no
    sudo redis-cli config rewrite
    sudo rm -f /var/lib/redis/appendonly.aof
}

# Update MeshCentral
updateMeshCentral()
{
    CURRENT_MESH_VER=$(cd /meshcentral/node_modules/meshcentral && node -p -e "require('./package.json').version")
    if [[ "${CURRENT_MESH_VER}" != "${LATEST_MESH_VER}" ]] || [[ "$force" = true ]]; then
        printf >&2 "${GREEN}Updating meshcentral from ${CURRENT_MESH_VER} to ${LATEST_MESH_VER}${NC}\n"
        sudo systemctl stop meshcentral
        sudo chown ${USER}:${USER} -R /meshcentral
        cd /meshcentral
        rm -rf node_modules/
        npm install meshcentral@${LATEST_MESH_VER}
        sudo systemctl start meshcentral
    fi
}

# Extract backup
extractBackup()
{
    ### Extract backup
    if [ ! -f "${1}" ]; then
        echo -ne "\n${RED}usage: ./restore.sh rmm-backup-xxxx.tar${NC}\n"
        exit 1
    fi

    print_green 'Unpacking backup'
    tmp_dir=$(mktemp -d -t tacticalrmm-XXXXXXXXXXXXXXXXXXXXX)

    tar -xf ${1} -C $tmp_dir
}


###############################
#  Troubleshooting functions  #
###############################

# Ping to test if domain is live
pingDomain()
{
    if ping -c 1 $1 &> /dev/null
    then
        echo -ne "${GREEN} Verified $1${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    else
        echo -ne "${RED} $1 doesnt exist please create it or check for a typo.${NC}" | tee -a checklog.log
        printf >&2 "\n\n"
        printf >&2 "You will have a log file called checklog.log in the directory you ran this script from.${NC}"
        printf >&2 "\n\n"
        exit
    fi
}

# Check IPs
checkIPisLive()
{
    locinputip=`dig @"$locdns" +short $1`
    reminputip=`dig @8.8.8.8 +short $1`

    if [ "$locinputip" = "$reminputip" ]; then
        echo -ne "${GREEN} Success $1 is Locally Resolved: ${locinputip}  Remotely Resolved: ${reminputip}${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    else
	    echo -ne "${RED} Locally Resolved: ${locinputip}  Remotely Resolved: ${reminputip}${NC}" | tee -a checklog.log
	    printf >&2 "\n\n" | tee -a checklog.log
        echo -ne "${RED} Your Local and Remote IP for $1 all agents will require non-public DNS to find TRMM server.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    fi
}

# Check services status
readServicesStatus()
{
    rmmstatus=$(systemctl is-active rmm)
    daphnestatus=$(systemctl is-active daphne)
    celerystatus=$(systemctl is-active celery)
    celerybeatstatus=$(systemctl is-active celerybeat)
    nginxstatus=$(systemctl is-active nginx)
    natsstatus=$(systemctl is-active nats)
    natsapistatus=$(systemctl is-active nats-api)
    meshcentralstatus=$(systemctl is-active meshcentral)
    mongodstatus=$(systemctl is-active mongod)
    postgresqlstatus=$(systemctl is-active postgresql)
    redisserverstatus=$(systemctl is-active redis-server)
}

# Verify services active
checkIfServiceActive()
{
    if [ $1 = active ]; then
        echo -ne "${GREEN} Success $2 is Running.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    else
	    printf >&2 "\n\n" | tee -a checklog.log
        echo -ne "${RED} $2 is not running. \(Tactical will not work without this\)${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
fi
}

# Check for open ports
isPortOpen()
{
    if ( nc -zv $wanip $1 2>&1 >/dev/null ); then
        echo -ne "${GREEN} $2 Port is open.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    else
        echo -ne "${RED} $2 port is closed. \(you may want this if running locally only\)${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    fi
}

# Check proxy
checkProxy()
{
    echo -ne "${YELLOW} Checking For Proxy.${NC}" | tee -a checklog.log 
	printf >&2 "\n\n"
	echo -ne "${YELLOW} ......this might take a while!!${NC}"
	printf >&2 "\n\n"

    # Detect Proxy via cert
    proxyext=$(openssl s_client -showcerts -servername $remapiip -connect $remapiip:443 2>/dev/null | openssl x509 -inform pem -noout -text)
    proxyint=$(openssl s_client -showcerts -servername 127.0.0.1 -connect 127.0.0.1:443 2>/dev/null | openssl x509 -inform pem -noout -text)

    if [[ $proxyext == $proxyint ]]; then
        echo -ne "${GREEN} No Proxy detected using Certificate.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    else
        echo -ne "${YELLOW} Proxy detected using Certificate.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    fi

    # Detect Proxy via IP
    if [ $wanip != $remrmmip ]; then
        echo -ne "${YELLOW} Proxy detected using IP.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    else
        echo -ne "${GREEN} No Proxy detected using IP.${NC}" | tee -a checklog.log
	    printf >&2 "\n\n"
    fi
}

# Check for valid cert
checkIfCertIsValid()
{
    echo -ne "${YELLOW} Checking if SSL Certificate is up to date.${NC}" | tee -a checklog.log 
	printf >&2 "\n\n"

    # SSL Certificate check
    cert=$(openssl verify -CAfile /etc/letsencrypt/live/$rootdomain/chain.pem /etc/letsencrypt/live/$rootdomain/cert.pem)

    if [[ "$cert" == *"OK"* ]]; then
        echo -ne "${GREEN} SSL Certificate for $rootdomain is fine.${NC}"  | tee -a checklog.log
	    printf >&2 "\n\n"
    else
        echo -ne "${RED} SSL Certificate has expired or doesnt exist for $rootdomain.${NC}"  | tee -a checklog.log
	    printf >&2 "\n\n"
    fi
}


######################
#  Parent Functions  #
######################

# Main install function
mainInstall()
{
  ### Repo info for Postegres and Mongo
  setInstallRepos;

  ### Create usernames and passwords
  generateUsersAndPass;

  ### This does... something
  cls;

  ### Get host/domain info
  getHostAndDomainInfo;

  ### Configure hosts file
  print_green 'Configuring Hosts file'
  configHosts;

  ### Certificate generation
  print_green 'Installing Certbot'
  installCertbot;

  ### Install Nginx
  print_green 'Installing Nginx'
  installNginx;

  ### Install NodeJS
  print_green 'Installing NodeJS'
  installNodeJS;

  ### Install and enable MongoDB
  print_green 'Installing MongoDB'
  installMongo;

  ### Install Python
  print_green "Installing Python ${PYTHON_VER}"
  installPython;

  ### Installing Redis
  print_green 'Installing redis'
  installRedis;

  ### Install and enable Postgresql
  print_green 'Installing postgresql'
  installPostgresql;

  ### Postgres DB creation
  print_green 'Creating database for the rmm'
  createPGDB;

  ### Clone main repo
  print_green 'Cloning primary repo'
  clonePrimaryRepo "install" "$REPO_URL" "$BRANCH";
  
  ### Clone scripts repo
  print_green 'Cloning community scripts repo'
  cloneScriptsRepo "install" "$SCRIPTS_REPO_URL";

  ### Installing NATS
  print_green 'Installing NATS'
  installNats "$INSTALL_TYPE";

  ### Install MeshCentral
  print_green 'Installing MeshCentral'
  installMeshCentral "install";
  
  ### Create MeshCentral config
  print_green 'Generating MeshCentral Config'
  createMeshConfig;

  ### Create local settings file
  print_green 'Generating Local Settings'
  createLocalSettings;

  ### Install NATS-API and correct permissions
  print_green 'Installing NATS API'
  installNatsApi;

  ### Install backend, configure primary admin user, setup admin 2fa
  print_green 'Installing the backend'
  configureBackend "install";
    
  ### Determine Proc setting for UWSGI
  print_green 'Optimizing UWSGI for number of processors'
  setUwsgiProcs;

  ### Create UWSGI config
  print_green 'Creating UWSGI configuration'
  createUwsgiConf;

  ### Create RMM UWSGI systemd service
  print_green 'Creating UWSGI service'
  createUwsgiService;

  ### Create Daphne systemd service
  print_green 'Creating Daphne service'
  createDaphneService;

  ### Create NATS systemd service
  print_green 'Creating NATS service'
  createNatsService;

  ### Create NATS-api systemd service
  print_green 'Creating NATS-API service'
  createNatsApiService;

  ### Create Backend Nginx site config
  print_green 'Creating Backend Nginx config'
  createBackendNginxConf;

  ### Create MeshCentral Nginx configuration
  print_green 'Creating MeshCentral Nginx config'
  createMeshNginxConf;

  ### Enable Mesh and RMM sites
  sudo ln -s /etc/nginx/sites-available/rmm.conf /etc/nginx/sites-enabled/rmm.conf
  sudo ln -s /etc/nginx/sites-available/meshcentral.conf /etc/nginx/sites-enabled/meshcentral.conf

  ### Create conf directory
  sudo mkdir /etc/conf.d

  ### Create Celery systemd service
  print_green 'Creating Celery service'
  createCeleryService;

  ### Configure Celery service
  print_green 'Creating Celery config'
  createCeleryConf;

  ### Create CeleryBeat systemd service
  print_green 'Creating CeleryBeat service'
  createCeleryBeatService;

  ### Correct conf dir ownership
  sudo chown ${USER}:${USER} -R /etc/conf.d/

  ### Create MeshCentral systemd service
  print_green 'Creating MeshCentral service'
  createMeshCentralService;

  ### Update services info
  sudo systemctl daemon-reload

  ### Verify and correct permissions
  if [ -d ~/.npm ]; then
    sudo chown -R $USER:$GROUP ~/.npm
  fi

  if [ -d ~/.config ]; then
    sudo chown -R $USER:$GROUP ~/.config
  fi

  ### Install frontend
  print_green 'Installing the frontend'
  installFrontEnd "install" "$FRONTEND_URL";

  ### Set front end Nginx config and enable
  print_green 'Creating Frontend Nginx config'
  createFrontendNginxConf;

  ### Enable Frontend site
  sudo ln -s /etc/nginx/sites-available/frontend.conf /etc/nginx/sites-enabled/frontend.conf

  ### Enable RMM, Daphne, Celery, and Nginx services
  print_green 'Enabling Services'

  for i in rmm.service daphne.service celery.service celerybeat.service nginx
  do
    sudo systemctl enable ${i}
    sudo systemctl stop ${i}
    sudo systemctl start ${i}
  done
  sleep 5

  ### Enable MeshCentral service
  print_green 'Starting meshcentral and waiting for it to install plugins'
  enableMeshService;

  ### Generating MeshCentral key
  print_green 'Generating meshcentral login token key'
  generateMeshToken;

  ### Configuring MeshCentral admin user and device group, restart service
  print_green 'Creating meshcentral account and group'
  configMeshUserGroup;

  ### Enable and configure NATS service
  print_green 'Starting NATS service'
  enableNatsService;

  ### Disable django admin
  sed -i 's/ADMIN_ENABLED = True/ADMIN_ENABLED = False/g' /rmm/api/tacticalrmm/tacticalrmm/local_settings.py

  ### Restart core services
  print_green 'Restarting services'

  for i in rmm.service daphne.service celery.service celerybeat.service
  do
    sudo systemctl stop ${i}
    sudo systemctl start ${i}
  done

  ### Yay, we're done!
  printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
  printf >&2 "\n\n"
  printf >&2 "${YELLOW}Installation complete!${NC}\n\n"
  printf >&2 "${YELLOW}Access your rmm at: ${GREEN}https://${frontenddomain}${NC}\n\n"
  printf >&2 "${YELLOW}Django admin url (disabled by default): ${GREEN}https://${rmmdomain}/${ADMINURL}/${NC}\n\n"
  printf >&2 "${YELLOW}MeshCentral username: ${GREEN}${meshusername}${NC}\n"
  printf >&2 "${YELLOW}MeshCentral password: ${GREEN}${MESHPASSWD}${NC}\n\n"

  if [ "$BEHIND_NAT" = true ]; then
    echo -ne "${YELLOW}Read below if your router does NOT support Hairpin NAT${NC}\n\n"
    echo -ne "${GREEN}If you will be accessing the web interface of the RMM from the same LAN as this server,${NC}\n"
    echo -ne "${GREEN}you'll need to make sure your 3 subdomains resolve to ${IPV4}${NC}\n"
    echo -ne "${GREEN}This also applies to any agents that will be on the same local network as the rmm.${NC}\n"
    echo -ne "${GREEN}You'll also need to setup port forwarding in your router on ports 80, 443 and 4222 tcp.${NC}\n\n"
  fi

  printf >&2 "${YELLOW}Please refer to the github README for next steps${NC}\n\n"
  printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
  printf >&2 "\n"
}

# Update function
updateTRMM()
{
    ### Check if user is same as during installation
    checkSameUser "update";

    ### Get current release version and check if update is necessary
    checkIfUpdate;

    ### Get current versions of necessary included apps
    checkAdditionalAppsVers;

    ### This does... something
    cls;

    ### Check CHECK_NATS_LIMITNOFILE, whatever that means
    checkNatsLimitNoFile;

    ### Check Nginx config
    installNginx "updatepart1";

    ### Stop services
    for i in nginx nats-api nats rmm daphne celery celerybeat
    do
        printf >&2 "${GREEN}Stopping ${i} service...${NC}\n"
        sudo systemctl stop ${i}
    done

    ### Rebuild uwsgi config
    rm -f /rmm/api/tacticalrmm/app.ini
    setUwsgiProcs;
    createUwsgiConf;

    ### Check additional Nginx settings and update
    installNginx "updatepart2";

    ### Check if Python is up to date, if not, update
    installPython "update";

    ### Check if NATS is up to date, if not, update
    installNats "update";

    ### This does stuff
    if [ -d ~/.npm ]; then
        sudo rm -rf ~/.npm
    fi

    if [ -d ~/.cache ]; then
        sudo rm -rf ~/.cache
    fi

    if [ -d ~/.config ]; then
        sudo chown -R $USER:$GROUP ~/.config
    fi

    ### Check NodeJS version, update if needed and update MeshCentral
    print_green 'Updating NodeJS'
    installNodeJS "update";

    ### Update from main repo
    print_green 'Cloning primary repo'
    clonePrimaryRepo "update" "$REPO_URL" "$BRANCH";

    ### Update from community-scripts repo
    print_green 'Cloning community scripts repo'
    cloneScriptsRepo "update" "$SCRIPTS_REPO_URL";

    ### Apply updated Ownership and perms
    sudo chown ${USER}:${USER} -R /rmm
    sudo chown ${USER}:${USER} -R ${SCRIPTS_DIR}
    sudo chown ${USER}:${USER} /var/log/celery
    sudo chown ${USER}:${USER} -R /etc/conf.d/
    sudo chown ${USER}:${USER} -R /etc/letsencrypt
    sudo chmod 775 -R /etc/letsencrypt

    ### Reconfigure backend
    configureBackend "update";

    ### Disable Redis append only
    turnOffRedisAppendOnly;

    ### Update Frontend
    installFrontEnd "update" "$FRONTEND_URL";

    ### Start services
    for i in nats nats-api rmm daphne celery celerybeat nginx
    do
        printf >&2 "${GREEN}Starting ${i} service${NC}\n"
        sudo systemctl start ${i}
    done
    sleep 1

    ### Push agent updates
    /rmm/api/env/bin/python /rmm/api/tacticalrmm/manage.py update_agents

    ### Update MeshCentral if necessary
    updateMeshCentral;

    ### Cleanup
    rm -f $TMP_SETTINGS

    ### Bye-bye
    printf >&2 "${GREEN}Update finished!${NC}\n"
}

# Backup Function
backupTRMM()
{
    ### Pull Postgres info
    POSTGRES_USER=$(grep -w USER /rmm/api/tacticalrmm/tacticalrmm/local_settings.py | sed 's/^.*: //' | sed 's/.//' | sed -r 's/.{2}$//')
    POSTGRES_PW=$(grep -w PASSWORD /rmm/api/tacticalrmm/tacticalrmm/local_settings.py | sed 's/^.*: //' | sed 's/.//' | sed -r 's/.{2}$//')

    ### Check if rmmbackup folder exists, if not create it
    if [ ! -d /rmmbackups ]; then
        sudo mkdir /rmmbackups
        sudo chown ${USER}:${USER} /rmmbackups
    fi

    ### Remove old MeshCentral backups
    if [ -d /meshcentral/meshcentral-backup ]; then
        rm -rf /meshcentral/meshcentral-backup/*
    fi

    ### Remove old MeshCentral DB backups
    if [ -d /meshcentral/meshcentral-coredumps ]; then
        rm -f /meshcentral/meshcentral-coredumps/*
    fi

    ### Set info for backup and folders
    dt_now=$(date '+%Y_%m_%d__%H_%M_%S')
    tmp_dir=$(mktemp -d -t tacticalrmm-XXXXXXXXXXXXXXXXXXXXX)
    sysd="/etc/systemd/system"

    ### Create temp backup subdirectories
    mkdir -p ${tmp_dir}/meshcentral/mongo
    mkdir ${tmp_dir}/postgres
    mkdir ${tmp_dir}/certs
    mkdir ${tmp_dir}/nginx
    mkdir ${tmp_dir}/systemd
    mkdir ${tmp_dir}/rmm
    mkdir ${tmp_dir}/confd

    ### Dump Postgres database
    pg_dump --dbname=postgresql://"${POSTGRES_USER}":"${POSTGRES_PW}"@127.0.0.1:5432/tacticalrmm | gzip -9 > ${tmp_dir}/postgres/db-${dt_now}.psql.gz

    ### Backup Mesh stuff
    tar -czvf ${tmp_dir}/meshcentral/mesh.tar.gz --exclude=/meshcentral/node_modules /meshcentral
    mongodump --gzip --out=${tmp_dir}/meshcentral/mongo

    ### Backup certs
    sudo tar -czvf ${tmp_dir}/certs/etc-letsencrypt.tar.gz -C /etc/letsencrypt .

    ### Backup Nginx configs
    sudo tar -czvf ${tmp_dir}/nginx/etc-nginx.tar.gz -C /etc/nginx .

    ### Backup other config files
    sudo tar -czvf ${tmp_dir}/confd/etc-confd.tar.gz -C /etc/conf.d .

    ### Copy service files
    sudo cp ${sysd}/rmm.service ${sysd}/celery.service ${sysd}/celerybeat.service ${sysd}/meshcentral.service ${sysd}/nats.service ${sysd}/daphne.service ${tmp_dir}/systemd/
    if [ -f "${sysd}/nats-api.service" ]; then
        sudo cp ${sysd}/nats-api.service ${tmp_dir}/systemd/
    fi

    cat /rmm/api/tacticalrmm/tacticalrmm/private/log/django_debug.log | gzip -9 > ${tmp_dir}/rmm/debug.log.gz
    cp /rmm/api/tacticalrmm/tacticalrmm/local_settings.py ${tmp_dir}/rmm/

    tar -cf /rmmbackups/rmm-backup-${dt_now}.tar -C ${tmp_dir} .

    ### Remove temp files/folders
    rm -rf ${tmp_dir}

    echo -ne "${GREEN}Backup saved to /rmmbackups/rmm-backup-${dt_now}.tar${NC}\n"
}

# Restore T-RMM
restoreTRMM()
{
    ### Repo info for Postegres and Mongo
    setInstallRepos;

    ### Extract backup
    extractBackup;

    ### Check if original user
    checkSameUser "restore";

    ### Install NodeJS
    print_green 'Installing NodeJS'
    installNodeJS "install";

    ### Install Nginx
    print_green 'Installing Nginx'
    installNginx "install";

    ### Restore Nginx configuration
    print_green 'Restoring Nginx configuration'

    sudo rm -rf /etc/nginx
    sudo mkdir /etc/nginx
    sudo tar -xzf $tmp_dir/nginx/etc-nginx.tar.gz -C /etc/nginx
    sudo sed -i 's/worker_connections.*/worker_connections 2048;/g' /etc/nginx/nginx.conf
    rmmdomain=$(grep server_name /etc/nginx/sites-available/rmm.conf | grep -v 301 | head -1 | tr -d " \t" | sed 's/.*server_name//' | tr -d ';')
    frontenddomain=$(grep server_name /etc/nginx/sites-available/frontend.conf | grep -v 301 | head -1 | tr -d " \t" | sed 's/.*server_name//' | tr -d ';')
    meshdomain=$(grep server_name /etc/nginx/sites-available/meshcentral.conf | grep -v 301 | head -1 | tr -d " \t" | sed 's/.*server_name//' | tr -d ';')

    ### Restore hosts config
    configHosts;

    ### Restore Certbot
    print_green 'Installing Certbot'
    installCertbot "restore";

    ### Restoring existing certs
    print_green 'Restoring certs'

    sudo rm -rf /etc/letsencrypt
    sudo mkdir /etc/letsencrypt
    sudo tar -xzf $tmp_dir/certs/etc-letsencrypt.tar.gz -C /etc/letsencrypt
    sudo chown ${USER}:${USER} -R /etc/letsencrypt
    sudo chmod 775 -R /etc/letsencrypt

    ### Restore Celery configs
    print_green 'Restoring celery configs'

    sudo mkdir /etc/conf.d
    sudo tar -xzf $tmp_dir/confd/etc-confd.tar.gz -C /etc/conf.d
    sudo chown ${USER}:${USER} -R /etc/conf.d

    ### Restoring services
    print_green 'Restoring systemd services'

    sudo cp $tmp_dir/systemd/* /etc/systemd/system/
    sudo systemctl daemon-reload

    ### Install Python
    print_green "Installing Python ${PYTHON_VER}"
    installPython;

    ### Installing Redis
    print_green 'Installing redis'
    installRedis;

    ### Install and enable Postgresql
    print_green 'Installing postgresql'
    installPostgresql;

    ### Install and enable MongoDB
    print_green 'Installing MongoDB'
    installMongo;

    ### Restore Mongo database
    print_green 'Restoring MongoDB'
    mongorestore --gzip $tmp_dir/meshcentral/mongo

    ### Clone main repo
    print_green 'Cloning primary repo'
    clonePrimaryRepo "install" "$REPO_URL" "$BRANCH";

    ### Clone scripts repo
    print_green 'Cloning community scripts repo'
    cloneScriptsRepo "install" "$SCRIPTS_REPO_URL";

    ### Installing NATS
    print_green 'Installing NATS'
    installNats "install";

    ### Restore MeshCentral
    print_green 'Restoring MeshCentral'
    installMeshCentral "restore";

    ### Restore UWSGI
    print_green 'Optimizing UWSGI for number of processors'
    setUwsgiProcs;
    print_green 'Creating UWSGI configuration'
    createUwsgiConf;

    ### Restoring other misc stuff
    cp $tmp_dir/rmm/local_settings.py /rmm/api/tacticalrmm/tacticalrmm/
    cp $tmp_dir/rmm/env /rmm/web/.env
    gzip -d $tmp_dir/rmm/debug.log.gz
    cp $tmp_dir/rmm/django_debug.log /rmm/api/tacticalrmm/tacticalrmm/private/log/

    ### Install NATS-API
    print_green 'Installing NATS API'
    installNatsApi;

    ### Restore Postgres database
    print_green 'Restoring the Postgres database'

    pgusername=$(grep -w USER /rmm/api/tacticalrmm/tacticalrmm/local_settings.py | sed 's/^.*: //' | sed 's/.//' | sed -r 's/.{2}$//')
    pgpw=$(grep -w PASSWORD /rmm/api/tacticalrmm/tacticalrmm/local_settings.py | sed 's/^.*: //' | sed 's/.//' | sed -r 's/.{2}$//')
    
    sudo -u postgres psql -c "DROP DATABASE IF EXISTS tacticalrmm"
    createPGDB;

    gzip -d $tmp_dir/postgres/*.psql.gz
    PGPASSWORD=${pgpw} psql -h localhost -U ${pgusername} -d tacticalrmm -f $tmp_dir/postgres/db*.psql

    ### Restore Backend
    print_green 'Restoring the backend'
    configureBackend "restore";

    ### Start NATS
    print_green 'Start NATS'
    sudo systemctl enable nats.service
    sudo systemctl start nats.service

    ### Install frontend
    print_green 'Installing the frontend'
    installFrontEnd;

    # reset perms
    sudo chown ${USER}:${USER} -R /rmm
    sudo chown ${USER}:${USER} /var/log/celery
    sudo chown ${USER}:${USER} -R /etc/conf.d/
    sudo chown -R $USER:$GROUP /home/${USER}/.npm
    sudo chown -R $USER:$GROUP /home/${USER}/.config
    sudo chown -R $USER:$GROUP /home/${USER}/.cache

    ### Update services info
    sudo systemctl daemon-reload

    ### Enable RMM, Daphne, Celery, Nats-api, and Nginx services
    print_green 'Enabling Services'

    for i in celery.service celerybeat.service rmm.service daphne.service nats-api.service nginx
    do
        sudo systemctl enable ${i}
        sudo systemctl stop ${i}
        sudo systemctl start ${i}
    done
    sleep 5

    ### Start MeshCentral
    print_green 'Starting meshcentral'
    sudo systemctl enable meshcentral
    sudo systemctl start meshcentral

    ### Done!!!!
    printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
    printf >&2 "\n\n"
    printf >&2 "${YELLOW}Restore complete!${NC}\n\n"
    printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
    printf >&2 "\n"
}

# Troubleshooting utility
troubleShoot()
{
    ### Resolve Locally used DNS server
    locdns=$(resolvectl | grep 'Current DNS Server:' | cut -d: -f2 | awk '{ print $1}')

    ### Prompt for host, domain, and email info
    getHostAndDomainInfo;

    ### Verify domains are live
    pingDomain "$rmmdomain";
    pingDomain "$frontenddomain";
    pingDomain "$meshdomain";

    ### Verify IPs
    echo -ne ${YELLOW} Checking IPs | tee -a checklog.log 
	printf >&2 "\n\n"
    checkIPisLive "$rmmdomain";
    remapiip="${reminputip}"
    checkIPisLive "$frontenddomain";
    checkIPisLive "$meshdomain";

    ### Get services status
    readServicesStatus;

    ### Verify services active
    checkIfServiceActive "$rmmstatus" "RMM Service";
    checkIfServiceActive "$daphnestatus" "Daphne Service";
    checkIfServiceActive "$celerystatus" "Celery Service";
    checkIfServiceActive "$celerybeatstatus" "CeleryBeat Service";
    checkIfServiceActive "$nginxstatus" "Nginx Service";
    checkIfServiceActive "$natsstatus" "NATS Service";
    checkIfServiceActive "$natsapistatus" "NATS-API Service";
    checkIfServiceActive "$meshcentralstatus" "MeshCentral Service";
    checkIfServiceActive "$mongodstatus" "MongoD Service";
    checkIfServiceActive "$postgresqlstatus" "Postgresql Service";
    checkIfServiceActive "$redisserverstatus" "Redis-Server Service";

    ### Get WAN IP
    wanip=$(dig @resolver4.opendns.com myip.opendns.com +short)
    echo -ne "${GREEN} WAN IP is $wanip.${NC}" | tee -a checklog.log
    printf >&2 "\n\n"

    ### Check if ports are open
    isPortOpen "4222" "NATS";
    isPortOpen "80" "HTTP";
    isPortOpen "443" "HTTPS";
    
    ### Checking Proxy
    checkProxy;

    ### Check for valid cert
    checkIfCertIsValid;

    ### Generate log summary
    echo -ne "${YELLOW} Getting summary output of logs.${NC}" | tee -a checklog.log  

    tail /rmm/api/tacticalrmm/tacticalrmm/private/log/django_debug.log  | tee -a checklog.log
	printf >&2 "\n\n"
    tail /rmm/api/tacticalrmm/tacticalrmm/private/log/error.log  | tee -a checklog.log
	printf >&2 "\n\n"

    printf >&2 "\n\n"
    echo -ne "${YELLOW} You will have a log file called checklog.log in the directory you ran this script from.${NC}"
    printf >&2 "\n\n"
}