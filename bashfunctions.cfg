########################
#  Input verification  #
########################

errortrack=0

# Translate user input to all lower case to prevent ID10T errors
translateToLowerCase()
{
	local lowercase=""
	lowercase="$(echo $1 | tr '[:upper:]' '[:lower:]')"
	echo "$lowercase"
}

# Function to track ID10T errors
derpDerp()
{
	if [ "$errortrack" -lt 12 ]; then
		errortrack=$((errortrack+1))
	fi

    derptext=""

	case $errortrack in
		1 ) derptext="Need some coffee?\n";;
		2 ) derptext="You should get some coffee.\n";;
		3 ) derptext="You are paying attention, right?\n";;
		4 ) derptext="All your typos are belong to us.\n";;
		5 ) derptext="We're sorry, your fingers are too fat.\n\nIf you would like to obtain a typing wand,\nplease mash your hand on the keyboard now.\n";;
		6 ) derptext="You have got to be kidding me...\n";;
		7 ) derptext="You're doing this intentionally, aren't you?\n";;
		8 ) derptext="Please step away from the keyboard, and back away slowly.\n";;
		9 ) derptext="You're making me angry. You wouldn't like me when I'm angry.\n";;
		10 ) derptext="How did you even get to this point?!?!?!?!\n";;
		11 ) derptext="Seriously, just give it up.\n";;
        * ) derptext="\*sigh\* Why are you still here?\n";;
	esac

    if [ "$errortrack" -lt 6 ]; then
        echo " "
        echo -e "${GREEN}${derptext}${NC}"
        echo -ne "${GREEN}Press any key to try again:${NC} "
        read anykey
        echo " "
    elif [ "$errortrack" -ge 6 ] && [ "$errortrack" -lt 10 ]; then
        echo " "
        echo -e "${YELLOW}${derptext}${NC}"
        echo -ne "${YELLOW}This really isn't that difficult. Press any key to try again:${NC} "
        read anykey
        echo " "
    elif [ "$errortrack" -ge 10 ]; then
        echo " "
        echo -e "${RED}${derptext}${NC}"
        echo -ne "${RED}The instructions are literally right there. Press any key to try again:${NC} "
        read anykey
        echo " "
    fi
	return
}

#######################################################################################
#  Misc Functions and variables, must be before any but input verification functions  #
#######################################################################################

CFG_VERSION="2"
CFG_URL='https://raw.githubusercontent.com/ninjamonkey198206/tacticalrmm/develop-bash-updates/bashfunctions.cfg'

# Set bash text colors
setColors()
{
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    RED='\033[0;31m'
    NC='\033[0m'
}

# Not defined
cls()
{
  printf "\033c"
}

# Purty install text
print_green()
{
  printf >&2 "${GREEN}%0.s-${NC}" {1..80}
  printf >&2 "\n"
  printf >&2 "${GREEN}${1}${NC}\n"
  printf >&2 "${GREEN}%0.s-${NC}" {1..80}
  printf >&2 "\n"
}

# Check for new script version
checkScriptVer()
{
    TMP_FILE=$(mktemp -p "" "rmminstall_XXXXXXXXXX")
    curl -s -L "$2" > ${TMP_FILE}
    NEW_VER=$(grep "^SCRIPT_VERSION" "$TMP_FILE" | awk -F'[="]' '{print $3}')

    if [ "$1" -ne "${NEW_VER}" ]; then
        printf >&2 "${YELLOW}Old $3 detected, downloading and replacing with the latest version...${NC}\n"
        wget -q "$2" -O $3
        printf >&2 "${YELLOW}Script updated! Please re-run .$3${NC}\n"
        rm -f $TMP_FILE
        exit 1
    fi

    rm -f $TMP_FILE
}

# Check for functions updates
checkCfgVer()
{
    TMP_FILE=$(mktemp -p "" "rmminstall_XXXXXXXXXX")
    curl -s -L "${CFG_URL}" > ${TMP_FILE}
    NEW_VER=$(grep "^CFG_VERSION" "$TMP_FILE" | awk -F'[="]' '{print $3}')

    if [ "${CFG_VERSION}" -ne "${NEW_VER}" ]; then
        printf >&2 "${YELLOW}Old bash function file detected, downloading and replacing with the latest version...${NC}\n"
        wget -q "${CFG_URL}" -O bashfunctions.cfg
        printf >&2 "${YELLOW}File updated! Please re-run .$1${NC}\n"
        rm -f $TMP_FILE
        exit 1
    fi

    rm -f $TMP_FILE
}

# Check for root as user
checkRoot()
{
    if [ $EUID -eq 0 ]; then
        echo -e "${RED}Do NOT run this script as root. Exiting.${NC}"
        exit 1
    fi
}


###########################
#  System info functions  #
###########################

# Gather OS info
getOSInfo()
{
    osname=$(lsb_release -si); osname=${osname^}
    osname=$(echo "$osname" | tr  '[A-Z]' '[a-z]')
    fullrel=$(lsb_release -sd)
    codename=$(lsb_release -sc)
    relno=$(lsb_release -sr | cut -d. -f1)
    fullrelno=$(lsb_release -sr)
}

# Check OS if not recognised
wutOSThis()
{
    if [ ! "$osname" = "ubuntu" ] && [ ! "$osname" = "debian" ]; then
        osname=$(grep -oP '(?<=^ID=).+' /etc/os-release | tr -d '"')
        osname=${osname^}
    fi
}

# Verify Debian or Ubuntu and version
verifySupportedOS()
{
    if ([ "$osname" = "ubuntu" ] && ([ "$fullrelno" = "20.04" ] || [ "$fullrelno" = "22.04" ])) || ([ "$osname" = "debian" ] && [ $relno -ge 10 ]); then
        echo $fullrel
    else
        echo $fullrel
        echo -e "${RED}Supported versions: Ubuntu 20.04 and 22.04, Debian 10 and 11.${NC}"
        echo -e "${RED}Your system does not appear to be supported.${NC}"
        exit 1
    fi
}

# Check language/locale
checkLocale()
{
    if [[ "$LANG" != *".UTF-8" ]]; then
        printf >&2 "\n${RED}System locale must be ${GREEN}<some language>.UTF-8${RED} not ${YELLOW}${LANG}${NC}\n"
        printf >&2 "${RED}Run the following command and change the default locale to your language of choice${NC}\n\n"
        printf >&2 "${GREEN}sudo dpkg-reconfigure locales${NC}\n\n"
        printf >&2 "${RED}You will need to log out and back in for changes to take effect, then re-run this script.${NC}\n\n"
        exit 1
    fi
}

# Clone primary repo
clonePrimaryRepo()
{
    sudo mkdir /rmm
    sudo chown ${USER}:${USER} /rmm
    sudo mkdir -p /var/log/celery
    sudo chown ${USER}:${USER} /var/log/celery
    git clone https://github.com/amidaware/tacticalrmm.git /rmm/
    cd /rmm
    git config user.email "admin@example.com"
    git config user.name "Bob"
    git checkout master
}

# Clone scripts repo
cloneScriptsRepo()
{
    sudo mkdir -p ${SCRIPTS_DIR}
    sudo chown ${USER}:${USER} ${SCRIPTS_DIR}
    git clone https://github.com/amidaware/community-scripts.git ${SCRIPTS_DIR}/
    cd ${SCRIPTS_DIR}
    git config user.email "admin@example.com"
    git config user.name "Bob"
    git checkout main
}


################
#  User Input  #
################

# Create usernames and passwords
generateUsersAndPass()
{
    manualpass="derp"

    DJANGO_SEKRET=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 80 | head -n 1)
    ADMINURL=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 70 | head -n 1)

    echo " "
    echo -ne "${YELLOW}If you would like to manually enter MeshCentral and Postgresql usernames and passwords${NC}\n"
    echo -ne "${YELLOW}type m or manual at the prompt, or simply press enter to have them randomly generated for you${NC}: "
    read manualpass
    manualpass="$(translateToLowerCase $manualpass)"
    echo " "

    if ([ "$manualpass" != "m" ] && [ "$manualpass" != "manual" ]); then
        MESHPASSWD=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 25 | head -n 1)
        pgusername=$(cat /dev/urandom | tr -dc 'a-z' | fold -w 8 | head -n 1)
        pgpw=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 20 | head -n 1)
        meshusername=$(cat /dev/urandom | tr -dc 'a-z' | fold -w 8 | head -n 1)
    
    elif ([ "$manualpass" == "m" ] || [ "$manualpass" == "manual" ]); then
        passinput=""
        userconfirm="n"
        MESHPASSWD=""
        pgusername=""
        pgpw=""
        meshusername=""

        until [ "$userconfirm" == "y" ]; do
            echo " "
            echo -ne "${YELLOW}Enter the MeshCentral admin username${NC}: "
            read meshusername
            echo " "
            echo -ne "${YELLOW}Is this correct? y or n${NC}: $meshusername "
            read userconfirm
            userconfirm="$(translateToLowerCase $userconfirm)"
            echo " "
        done
        userconfirm="n"

        until [ "$passinput" == "$MESHPASSWD" ]; do
            read -s -p "Enter the MeshCentral admin password: " MESHPASSWD
            echo " "
            read -s -p "Re-enter the MeshCentral admin password: " passinput
            if [ "$passinput" != "$MESHPASSWD" ]; then
                echo " "
                echo -e "${YELLOW}Passwords do not match. Press any key to try again${NC}: "
                read anykey
            else
                echo " "
            fi
        done

        until [ "$userconfirm" == "y" ]; do
            echo " "
            echo -ne "${YELLOW}Enter the Postgresql admin username${NC}: "
            read pgusername
            echo " "
            echo -ne "${YELLOW}Is this correct? y or n${NC}: $pgusername "
            read userconfirm
            userconfirm="$(translateToLowerCase $userconfirm)"
            echo " "
        done
        userconfirm="n"

        until [ "$passinput" == "$pgpw" ]; do
            read -s -p "Enter the Postgresql admin password: " pgpw
            echo " "
            read -s -p "Re-enter the Postgresql admin password: " passinput
            if [ "$passinput" != "$pgpw" ]; then
                echo " "
                echo -e "${YELLOW}Passwords do not match. Press any key to try again${NC}: "
                read anykey
            else
                echo " "
            fi
        done
    fi
}

# Get host and domain info
getHostAndDomainInfo()
{
    hostsconfirm="n"

    until [ $hostsconfirm == "y" ]; do
        rootdomain="none"
        letsemail="none"
        while [[ $rootdomain != *[.]* ]]; do
            echo -ne "${YELLOW}Enter the root domain (e.g. example.com or example.co.uk)${NC}: "
            read rootdomain
            rootdomain="$(translateToLowerCase $rootdomain)"
            echo " "
        done

        echo -ne "${YELLOW}Enter the hostname for the backend (e.g. api)${NC}: "
        read rmmhost
        rmmhost="$(translateToLowerCase $rmmhost)"
        echo " "

        echo -ne "${YELLOW}Enter the hostname for the frontend (e.g. rmm)${NC}: "
        read frontendhost
        frontendhost="$(translateToLowerCase $frontendhost)"
        echo " "

        echo -ne "${YELLOW}Enter the hostname for meshcentral (e.g. mesh)${NC}: "
        read meshhost
        meshhost="$(translateToLowerCase $meshhost)"
        echo " "

        while [[ $letsemail != *[@]*[.]* ]]; do
            echo -ne "${YELLOW}Enter a valid e-mail address for django, meshcentral, and letsencrypt${NC}: "
            read letsemail 
            letsemail="$(translateToLowerCase $letsemail)"
            echo " "
        done

        echo " "
        echo "${YELLOW}root domain${NC}: $rootdomain"
        echo "${YELLOW}backend${NC}: $rmmhost.$rootdomain"
        echo "${YELLOW}frontend${NC}: $frontendhost.$rootdomain"
        echo "${YELLOW}meshcentral${NC}: $meshhost.$rootdomain"
        echo "${YELLOW}e-mail address${NC}: $letsemail"
        echo " "
        echo -ne "${YELLOW}Is this correct? y or n${NC}: "
        read hostsconfirm
        hostsconfirm="$(translateToLowerCase $hostsconfirm)"
    done

    rmmdomain="$rmmhost.$rootdomain"
    meshdomain="$meshhost.$rootdomain"
    frontenddomain="$frontendhost.$rootdomain"
}


#######################
#  Network Functions  #
#######################

# Check hosts file, add hosts
configHosts()
{
    # If server is behind NAT we need to add the 3 subdomains to the host file
    # so that nginx can properly route between the frontend, backend and meshcentral
    # EDIT 8-29-2020
    # running this even if server is __not__ behind NAT just to make DNS resolving faster
    # this also allows the install script to properly finish even if DNS has not fully propagated
    CHECK_HOSTS=$(grep 127.0.1.1 /etc/hosts | grep "$rmmdomain" | grep "$meshdomain" | grep "$frontenddomain")
    HAS_11=$(grep 127.0.1.1 /etc/hosts)

    if ! [[ $CHECK_HOSTS ]]; then
        print_green 'Adding subdomains to hosts file'
        if [[ $HAS_11 ]]; then
            sudo sed -i "/127.0.1.1/s/$/ ${rmmdomain} ${frontenddomain} ${meshdomain}/" /etc/hosts
        else
            echo "127.0.1.1 ${rmmdomain} ${frontenddomain} ${meshdomain}" | sudo tee --append /etc/hosts > /dev/null
        fi
    fi

    BEHIND_NAT=false
    IPV4=$(ip -4 addr | sed -ne 's|^.* inet \([^/]*\)/.* scope global.*$|\1|p' | head -1)
    if echo "$IPV4" | grep -qE '^(10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.|192\.168)'; then
        BEHIND_NAT=true
    fi
}


#######################
#  Install Functions  #
#######################

# Install script prereqs
installPreReqs()
{
    sudo apt update && sudo apt install -y curl wget dirmngr gnupg lsb-release
}

# Install remaining prereqs
installAdditionalPreReqs()
{
    sudo apt install -y software-properties-common openssl ca-certificates apt-transport-https gcc g++ make build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libsqlite3-dev libbz2-dev git
}

# Configure repos for stuff
setInstallRepos()
{
    # There is no Jammy repo yet so use Focal for Ubuntu 22.04
    if ([ "$osname" = "ubuntu" ] && [ "$fullrelno" = "20.04" ]); then
        mongodb_repo="deb [arch=amd64] https://repo.mongodb.org/apt/$osname $codename/mongodb-org/4.4 multiverse"
    elif ([ "$osname" = "ubuntu" ] && [ "$fullrelno" = "22.04" ]); then
        codename="focal"
        mongodb_repo="deb [arch=amd64] https://repo.mongodb.org/apt/$osname $codename/mongodb-org/4.4 multiverse"
    # There is no bullseye repo yet for mongo so just use Buster on Debian 11
    elif ([ "$osname" = "debian" ] && [ $relno -eq 10 ]); then
        mongodb_repo="deb [arch=amd64] https://repo.mongodb.org/apt/$osname $codename/mongodb-org/4.4 main"
    else
        codename="buster"
        mongodb_repo="deb [arch=amd64] https://repo.mongodb.org/apt/$osname $codename/mongodb-org/4.4 main"
    fi

    postgresql_repo="deb [arch=amd64] https://apt.postgresql.org/pub/repos/apt/ $codename-pgdg main"
}

# Install MongoDB
installMongo()
{
    wget -qO - https://www.mongodb.org/static/pgp/server-4.4.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/mongo.gpg > /dev/null
    echo "$mongodb_repo" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.4.list
    sudo apt update && sudo apt install -y mongodb-org
    sudo systemctl enable mongod
    sudo systemctl restart mongod
    sleep 5
}

# Install NodeJS
installNodeJS()
{
    if [ "$1" == "update" ]; then
        HAS_NODE16=$(node --version | grep v16)
        if ! [[ $HAS_NODE16 ]]; then
            printf >&2 "${GREEN}Updating NodeJS to v16${NC}\n"
            rm -rf /rmm/web/node_modules
            sudo systemctl stop meshcentral
            sudo apt remove -y nodejs
            sudo rm -rf /usr/lib/node_modules
        fi
    fi
    curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -
    sudo apt update && sudo apt install -y nodejs
    sudo npm install -g npm
    if [ "$1" == "update" ]; then
        sudo chown ${USER}:${USER} -R /meshcentral
        cd /meshcentral
        rm -rf node_modules/
        npm install meshcentral@${LATEST_MESH_VER}
        sudo systemctl start meshcentral
    fi
}

# Install Redis
installRedis()
{
    sudo apt install -y redis
}

# Install Python
installPython()
{
    if [ "$1" == "update" ]; then
        HAS_PY310=$(python3.10 --version | grep ${PYTHON_VER})
        if ! [[ $HAS_PY310 ]]; then
            printf >&2 "${GREEN}Updating to ${PYTHON_VER}${NC}\n"
        fi
    fi
    numprocs=$(nproc)
    cd ~
    wget https://www.python.org/ftp/python/${PYTHON_VER}/Python-${PYTHON_VER}.tgz
    tar -xf Python-${PYTHON_VER}.tgz
    cd Python-${PYTHON_VER}
    ./configure --enable-optimizations
    make -j $numprocs
    sudo make altinstall
    cd ~
    sudo rm -rf Python-${PYTHON_VER} Python-${PYTHON_VER}.tgz
}

# Install Postgresql
installPostgresql()
{
    echo "$postgresql_repo" | sudo tee /etc/apt/sources.list.d/pgdg.list
    wget -qO - https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/postgresql.gpg > /dev/null
    sudo apt update && sudo apt install -y postgresql-14
    sleep 2
    sudo systemctl enable postgresql
    sudo systemctl restart postgresql
    sleep 5
}

# Install NATS
installNats()
{
    if [ "$1" == "update" ]; then
        HAS_LATEST_NATS=$(/usr/local/bin/nats-server -version | grep "${NATS_SERVER_VER}")
        if ! [[ $HAS_LATEST_NATS ]]; then
            printf >&2 "${GREEN}Updating nats to v${NATS_SERVER_VER}${NC}\n"
        fi
    fi
    if [ "$1" == "install" ]; then
        NATS_SERVER_VER=$(grep "^NATS_SERVER_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')
    fi
    nats_tmp=$(mktemp -d -t nats-XXXXXXXXXX)
    wget https://github.com/nats-io/nats-server/releases/download/v${NATS_SERVER_VER}/nats-server-v${NATS_SERVER_VER}-linux-amd64.tar.gz -P ${nats_tmp}
    tar -xzf ${nats_tmp}/nats-server-v${NATS_SERVER_VER}-linux-amd64.tar.gz -C ${nats_tmp}
    if [ "$1" == "update" ]; then
        sudo rm -f /usr/local/bin/nats-server
    fi
    sudo mv ${nats_tmp}/nats-server-v${NATS_SERVER_VER}-linux-amd64/nats-server /usr/local/bin/
    sudo chmod +x /usr/local/bin/nats-server
    sudo chown ${USER}:${USER} /usr/local/bin/nats-server
    rm -rf ${nats_tmp}
}

# Install frontend
installFrontEnd()
{
    webtar="trmm-web-v${WEB_VERSION}.tar.gz"
    wget -q https://github.com/amidaware/tacticalrmm-web/releases/download/v${WEB_VERSION}/${webtar} -O /tmp/${webtar}
    sudo mkdir -p /var/www/rmm
    sudo tar -xzf /tmp/${webtar} -C /var/www/rmm
    echo "window._env_ = {PROD_URL: \"https://${rmmdomain}\"}" | sudo tee /var/www/rmm/dist/env-config.js > /dev/null
    sudo chown www-data:www-data -R /var/www/rmm/dist
    rm -f /tmp/${webtar}
}

# Install Nginx
installNginx()
{
    if [ "$1" == "install" ]; then
	    sudo apt install -y nginx
	    sudo systemctl stop nginx
        sudo sed -i 's/worker_connections.*/worker_connections 2048;/g' /etc/nginx/nginx.conf
        sudo sed -i 's/# server_names_hash_bucket_size.*/server_names_hash_bucket_size 64;/g' /etc/nginx/nginx.conf
    elif [ "$1" == "updatepart1" ]; then
        ### Check Nginx config
        if ! sudo nginx -t > /dev/null 2>&1; then
            sudo nginx -t
            echo -ne "\n"
            echo -ne "${RED}You have syntax errors in your nginx configs. See errors above. Please fix them and re-run this script.${NC}\n"
            echo -ne "${RED}Aborting...${NC}\n"
            exit 1
        fi
    elif [ "$1" == "updatepart2" ]; then
        CHECK_NGINX_WORKER_CONN=$(grep "worker_connections 2048" /etc/nginx/nginx.conf)
        if ! [[ $CHECK_NGINX_WORKER_CONN ]]; then
            printf >&2 "${GREEN}Changing nginx worker connections to 2048${NC}\n"
            sudo sed -i 's/worker_connections.*/worker_connections 2048;/g' /etc/nginx/nginx.conf
        fi
        sudo sed -i 's/# server_names_hash_bucket_size.*/server_names_hash_bucket_size 64;/g' /etc/nginx/nginx.conf
    else
        echo " "
    fi
}

# Install NATS Api
installNatsApi()
{
    sudo cp /rmm/natsapi/bin/nats-api /usr/local/bin
    sudo chown ${USER}:${USER} /usr/local/bin/nats-api
    sudo chmod +x /usr/local/bin/nats-api
}

# Install MeshCentral
installMeshCentral()
{
    MESH_VER=$(grep "^MESH_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')

    sudo mkdir -p /meshcentral/meshcentral-data
    sudo chown ${USER}:${USER} -R /meshcentral
    cd /meshcentral
    npm install meshcentral@${MESH_VER}
    sudo chown ${USER}:${USER} -R /meshcentral
}


########################
#  Database Functions  #
########################

# Postgres DB creation
createPGDB()
{
	sudo -u postgres psql -c "CREATE DATABASE tacticalrmm"
	sudo -u postgres psql -c "CREATE USER ${pgusername} WITH PASSWORD '${pgpw}'"
	sudo -u postgres psql -c "ALTER ROLE ${pgusername} SET client_encoding TO 'utf8'"
	sudo -u postgres psql -c "ALTER ROLE ${pgusername} SET default_transaction_isolation TO 'read committed'"
	sudo -u postgres psql -c "ALTER ROLE ${pgusername} SET timezone TO 'UTC'"
	sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE tacticalrmm TO ${pgusername}"
}

###########################
#  Certificate Functions  #
###########################

# Install Certbot and get initial certs
installCertbot()
{
    sudo apt install -y certbot

    print_green 'Getting wildcard cert'

    sudo certbot certonly --manual -d *.${rootdomain} --agree-tos --no-bootstrap --preferred-challenges dns -m ${letsemail} --no-eff-email
    while [[ $? -ne 0 ]]; do
        sudo certbot certonly --manual -d *.${rootdomain} --agree-tos --no-bootstrap --preferred-challenges dns -m ${letsemail} --no-eff-email
    done

    CERT_PRIV_KEY=/etc/letsencrypt/live/${rootdomain}/privkey.pem
    CERT_PUB_KEY=/etc/letsencrypt/live/${rootdomain}/fullchain.pem

    sudo chown ${USER}:${USER} -R /etc/letsencrypt
    sudo chmod 775 -R /etc/letsencrypt
}


#######################################
#  Config file and service functions  #
#######################################

# Generate mesh configuration
createMeshConfig()
{
    meshcfg="$(cat << EOF
    {
    "settings": {
        "Cert": "${meshdomain}",
        "MongoDb": "mongodb://127.0.0.1:27017",
        "MongoDbName": "meshcentral",
        "WANonly": true,
        "Minify": 1,
        "Port": 4443,
        "AgentAliasPort": 443,
        "AliasPort": 443,
        "AllowLoginToken": true,
        "AllowFraming": true,
        "_AgentPing": 60,
        "AgentPong": 300,
        "AllowHighQualityDesktop": true,
        "TlsOffload": "127.0.0.1",
        "agentCoreDump": false,
        "Compression": true,
        "WsCompression": true,
        "AgentWsCompression": true,
        "MaxInvalidLogin": { "time": 5, "count": 5, "coolofftime": 30 }
    },
    "domains": {
        "": {
            "Title": "Tactical RMM",
            "Title2": "Tactical RMM",
            "NewAccounts": false,
            "CertUrl": "https://${meshdomain}/",
            "GeoLocation": true,
            "CookieIpCheck": false,
            "mstsc": true
            }
        }
    }
    EOF
    )"
    echo "${meshcfg}" > /meshcentral/meshcentral-data/config.json
}

# Generate local settings file
createLocalSettings()
{
    localvars="$(cat << EOF
    SECRET_KEY = "${DJANGO_SEKRET}"

    DEBUG = False

    ALLOWED_HOSTS = ['${rmmdomain}']

    ADMIN_URL = "${ADMINURL}/"

    CORS_ORIGIN_WHITELIST = [
        "https://${frontenddomain}"
    ]

    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.postgresql',
            'NAME': 'tacticalrmm',
            'USER': '${pgusername}',
            'PASSWORD': '${pgpw}',
            'HOST': 'localhost',
            'PORT': '5432',
        }
    }

    MESH_USERNAME = "${meshusername}"
    MESH_SITE = "https://${meshdomain}"
    REDIS_HOST    = "localhost"
    ADMIN_ENABLED = True
    EOF
    )"
    echo "${localvars}" > /rmm/api/tacticalrmm/tacticalrmm/local_settings.py
}

# Backend configuration
configureBackend()
{
    SETUPTOOLS_VER=$(grep "^SETUPTOOLS_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')
    WHEEL_VER=$(grep "^WHEEL_VER" "$SETTINGS_FILE" | awk -F'[= "]' '{print $5}')

    cd /rmm/api
    python3.10 -m venv env
    source /rmm/api/env/bin/activate
    cd /rmm/api/tacticalrmm
    pip install --no-cache-dir --upgrade pip
    pip install --no-cache-dir setuptools==${SETUPTOOLS_VER} wheel==${WHEEL_VER}
    pip install --no-cache-dir -r /rmm/api/tacticalrmm/requirements.txt
    python manage.py migrate
    python manage.py collectstatic --no-input
    python manage.py create_natsapi_conf
    python manage.py load_chocos
    python manage.py load_community_scripts
    WEB_VERSION=$(python manage.py get_config webversion)
    printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
    printf >&2 "\n"
    printf >&2 "${YELLOW}Please create your login for the RMM website and django admin${NC}\n"
    printf >&2 "${YELLOW}%0.s*${NC}" {1..80}
    printf >&2 "\n"
    echo -ne "Username: "
    read djangousername
    python manage.py createsuperuser --username ${djangousername} --email ${letsemail}
    python manage.py create_installer_user
    RANDBASE=$(python manage.py generate_totp)
    cls
    python manage.py generate_barcode ${RANDBASE} ${djangousername} ${frontenddomain}
    deactivate
    read -n 1 -s -r -p "Press any key to continue..."
}

# Set uwsgi procs
setUwsgiProcs()
{
    uwsgiprocs=4
    if [[ "$numprocs" == "1" ]]; then
        uwsgiprocs=2
    else
        uwsgiprocs=$numprocs
    fi
}

# Create UWSGI config
createUwsgiConf()
{
    uwsgini="$(cat << EOF
    [uwsgi]
    chdir = /rmm/api/tacticalrmm
    module = tacticalrmm.wsgi
    home = /rmm/api/env
    master = true
    processes = ${uwsgiprocs}
    threads = ${uwsgiprocs}
    enable-threads = true
    socket = /rmm/api/tacticalrmm/tacticalrmm.sock
    harakiri = 300
    chmod-socket = 660
    buffer-size = 65535
    vacuum = true
    die-on-term = true
    max-requests = 500
    disable-logging = true
    EOF
    )"
    echo "${uwsgini}" > /rmm/api/tacticalrmm/app.ini
}

# Create UWSGI service
createUwsgiService()
{
    rmmservice="$(cat << EOF
    [Unit]
    Description=tacticalrmm uwsgi daemon
    After=network.target postgresql.service

    [Service]
    User=${USER}
    Group=www-data
    WorkingDirectory=/rmm/api/tacticalrmm
    Environment="PATH=/rmm/api/env/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    ExecStart=/rmm/api/env/bin/uwsgi --ini app.ini
    Restart=always
    RestartSec=10s

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${rmmservice}" | sudo tee /etc/systemd/system/rmm.service > /dev/null
}

# Create Daphne service
createDaphneService()
{
    daphneservice="$(cat << EOF
    [Unit]
    Description=django channels daemon
    After=network.target

    [Service]
    User=${USER}
    Group=www-data
    WorkingDirectory=/rmm/api/tacticalrmm
    Environment="PATH=/rmm/api/env/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    ExecStart=/rmm/api/env/bin/daphne -u /rmm/daphne.sock tacticalrmm.asgi:application
    Restart=always
    RestartSec=3s

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${daphneservice}" | sudo tee /etc/systemd/system/daphne.service > /dev/null
}

# Create NATS service
createNatsService()
{
    natsservice="$(cat << EOF
    [Unit]
    Description=NATS Server
    After=network.target

    [Service]
    PrivateTmp=true
    Type=simple
    ExecStart=/usr/local/bin/nats-server -c /rmm/api/tacticalrmm/nats-rmm.conf
    ExecReload=/usr/bin/kill -s HUP \$MAINPID
    ExecStop=/usr/bin/kill -s SIGINT \$MAINPID
    User=${USER}
    Group=www-data
    Restart=always
    RestartSec=5s
    LimitNOFILE=1000000

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${natsservice}" | sudo tee /etc/systemd/system/nats.service > /dev/null
}

# Create NATS service
createNatsApiService()
{
    natsapi="$(cat << EOF
    [Unit]
    Description=TacticalRMM Nats Api v1
    After=nats.service

    [Service]
    Type=simple
    ExecStart=/usr/local/bin/nats-api
    User=${USER}
    Group=${USER}
    Restart=always
    RestartSec=5s

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${natsapi}" | sudo tee /etc/systemd/system/nats-api.service > /dev/null
}

# Create backend nginx conf
createBackendNginxConf()
{
    nginxrmm="$(cat << EOF
    server_tokens off;

    upstream tacticalrmm {
        server unix:////rmm/api/tacticalrmm/tacticalrmm.sock;
    }

    map \$http_user_agent \$ignore_ua {
        "~python-requests.*" 0;
        "~go-resty.*" 0;
        default 1;
    }

    server {
        listen 80;
        listen [::]:80;
        server_name ${rmmdomain};
        return 301 https://\$server_name\$request_uri;
    }

    server {
        listen 443 ssl;
        listen [::]:443 ssl;
        server_name ${rmmdomain};
        client_max_body_size 300M;
        access_log /rmm/api/tacticalrmm/tacticalrmm/private/log/access.log combined if=\$ignore_ua;
        error_log /rmm/api/tacticalrmm/tacticalrmm/private/log/error.log;
        ssl_certificate ${CERT_PUB_KEY};
        ssl_certificate_key ${CERT_PRIV_KEY};
    
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers EECDH+AESGCM:EDH+AESGCM;
        ssl_ecdh_curve secp384r1;
        ssl_stapling on;
        ssl_stapling_verify on;
        add_header X-Content-Type-Options nosniff;
    
        location /static/ {
            root /rmm/api/tacticalrmm;
        }

        location /private/ {
            internal;
            add_header "Access-Control-Allow-Origin" "https://${frontenddomain}";
            alias /rmm/api/tacticalrmm/tacticalrmm/private/;
        }

        location ~ ^/ws/ {
            proxy_pass http://unix:/rmm/daphne.sock;

            proxy_http_version 1.1;
            proxy_set_header Upgrade \$http_upgrade;
            proxy_set_header Connection "upgrade";

            proxy_redirect     off;
            proxy_set_header   Host \$host;
            proxy_set_header   X-Real-IP \$remote_addr;
            proxy_set_header   X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Host \$server_name;
        }

        location / {
            uwsgi_pass  tacticalrmm;
            include     /etc/nginx/uwsgi_params;
            uwsgi_read_timeout 300s;
            uwsgi_ignore_client_abort on;
        }
    }
    EOF
    )"
    echo "${nginxrmm}" | sudo tee /etc/nginx/sites-available/rmm.conf > /dev/null
}

# Create Mesh nginx conf
createMeshNginxConf()
{
    nginxmesh="$(cat << EOF
    server {
        listen 80;
        listen [::]:80;
        server_name ${meshdomain};
        return 301 https://\$server_name\$request_uri;
    }

    server {
        listen 443 ssl;
        listen [::]:443 ssl;
        proxy_send_timeout 330s;
        proxy_read_timeout 330s;
        server_name ${meshdomain};
        ssl_certificate ${CERT_PUB_KEY};
        ssl_certificate_key ${CERT_PRIV_KEY};

        ssl_session_cache shared:WEBSSL:10m;

        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers EECDH+AESGCM:EDH+AESGCM;
        ssl_ecdh_curve secp384r1;
        ssl_stapling on;
        ssl_stapling_verify on;
        add_header X-Content-Type-Options nosniff;

        location / {
            proxy_pass http://127.0.0.1:4443/;
            proxy_http_version 1.1;

            proxy_set_header Host \$host;
            proxy_set_header Upgrade \$http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header X-Forwarded-Host \$host:\$server_port;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }
    }
    EOF
    )"
    echo "${nginxmesh}" | sudo tee /etc/nginx/sites-available/meshcentral.conf > /dev/null
}

# Create Celery service
createCeleryService()
{
    celeryservice="$(cat << EOF
    [Unit]
    Description=Celery Service V2
    After=network.target redis-server.service postgresql.service

    [Service]
    Type=forking
    User=${USER}
    Group=${USER}
    EnvironmentFile=/etc/conf.d/celery.conf
    WorkingDirectory=/rmm/api/tacticalrmm
    ExecStart=/bin/sh -c '\${CELERY_BIN} -A \$CELERY_APP multi start \$CELERYD_NODES --pidfile=\${CELERYD_PID_FILE} --logfile=\${CELERYD_LOG_FILE} --loglevel="\${CELERYD_LOG_LEVEL}" \$CELERYD_OPTS'
    ExecStop=/bin/sh -c '\${CELERY_BIN} multi stopwait \$CELERYD_NODES --pidfile=\${CELERYD_PID_FILE} --loglevel="\${CELERYD_LOG_LEVEL}"'
    ExecReload=/bin/sh -c '\${CELERY_BIN} -A \$CELERY_APP multi restart \$CELERYD_NODES --pidfile=\${CELERYD_PID_FILE} --logfile=\${CELERYD_LOG_FILE} --loglevel="\${CELERYD_LOG_LEVEL}" \$CELERYD_OPTS'
    Restart=always
    RestartSec=10s

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${celeryservice}" | sudo tee /etc/systemd/system/celery.service > /dev/null
}

# Create Celery config
createCeleryConf()
{
    celeryconf="$(cat << EOF
    CELERYD_NODES="w1"

    CELERY_BIN="/rmm/api/env/bin/celery"

    CELERY_APP="tacticalrmm"

    CELERYD_MULTI="multi"

    CELERYD_OPTS="--time-limit=86400 --autoscale=20,2"

    CELERYD_PID_FILE="/rmm/api/tacticalrmm/%n.pid"
    CELERYD_LOG_FILE="/var/log/celery/%n%I.log"
    CELERYD_LOG_LEVEL="ERROR"

    CELERYBEAT_PID_FILE="/rmm/api/tacticalrmm/beat.pid"
    CELERYBEAT_LOG_FILE="/var/log/celery/beat.log"
    EOF
    )"
    echo "${celeryconf}" | sudo tee /etc/conf.d/celery.conf > /dev/null
}

# Create CeleryBeat service
createCeleryBeatService()
{
    celerybeatservice="$(cat << EOF
    [Unit]
    Description=Celery Beat Service V2
    After=network.target redis-server.service postgresql.service

    [Service]
    Type=simple
    User=${USER}
    Group=${USER}
    EnvironmentFile=/etc/conf.d/celery.conf
    WorkingDirectory=/rmm/api/tacticalrmm
    ExecStart=/bin/sh -c '\${CELERY_BIN} -A \${CELERY_APP} beat --pidfile=\${CELERYBEAT_PID_FILE} --logfile=\${CELERYBEAT_LOG_FILE} --loglevel=\${CELERYD_LOG_LEVEL}'
    Restart=always
    RestartSec=10s

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${celerybeatservice}" | sudo tee /etc/systemd/system/celerybeat.service > /dev/null
}

# Create MeshCentral service
createMeshCentralService()
{
    meshservice="$(cat << EOF
    [Unit]
    Description=MeshCentral Server
    After=network.target mongod.service nginx.service
    [Service]
    Type=simple
    LimitNOFILE=1000000
    ExecStart=/usr/bin/node node_modules/meshcentral
    Environment=NODE_ENV=production
    WorkingDirectory=/meshcentral
    User=${USER}
    Group=${USER}
    Restart=always
    RestartSec=10s

    [Install]
    WantedBy=multi-user.target
    EOF
    )"
    echo "${meshservice}" | sudo tee /etc/systemd/system/meshcentral.service > /dev/null
}

# Create Frontend Nginx config
createFrontendNginxConf()
{
    nginxfrontend="$(cat << EOF
    server {
        server_name ${frontenddomain};
        charset utf-8;
        location / {
            root /var/www/rmm/dist;
            try_files \$uri \$uri/ /index.html;
            add_header Cache-Control "no-store, no-cache, must-revalidate";
            add_header Pragma "no-cache";
        }
        error_log  /var/log/nginx/frontend-error.log;
        access_log /var/log/nginx/frontend-access.log;

        listen 443 ssl;
        listen [::]:443 ssl;
        ssl_certificate ${CERT_PUB_KEY};
        ssl_certificate_key ${CERT_PRIV_KEY};
    
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers EECDH+AESGCM:EDH+AESGCM;
        ssl_ecdh_curve secp384r1;
        ssl_stapling on;
        ssl_stapling_verify on;
        add_header X-Content-Type-Options nosniff;
    }

    server {
        if (\$host = ${frontenddomain}) {
            return 301 https://\$host\$request_uri;
        }

        listen 80;
        listen [::]:80;
        server_name ${frontenddomain};
        return 404;
    }
    EOF
    )"
    echo "${nginxfrontend}" | sudo tee /etc/nginx/sites-available/frontend.conf > /dev/null
}

# Generate Mesh Token
generateMeshToken()
{
    MESHTOKENKEY="$(node /meshcentral/node_modules/meshcentral --logintokenkey)"

    meshtoken="$(cat << EOF
    MESH_TOKEN_KEY = "${MESHTOKENKEY}"
    EOF
    )"
    echo "${meshtoken}" | tee --append /rmm/api/tacticalrmm/tacticalrmm/local_settings.py > /dev/null
}

# Configure Mesh user and group, restart service
configMeshUserGroup()
{
    sudo systemctl stop meshcentral
    sleep 1
    cd /meshcentral

    node node_modules/meshcentral --createaccount ${meshusername} --pass ${MESHPASSWD} --email ${letsemail}
    sleep 1
    node node_modules/meshcentral --adminaccount ${meshusername}

    sudo systemctl start meshcentral
    sleep 5

    while ! [[ $CHECK_MESH_READY2 ]]; do
        CHECK_MESH_READY2=$(sudo journalctl -u meshcentral.service -b --no-pager | grep "MeshCentral HTTP server running on port")
        echo -ne "${GREEN}Mesh Central not ready yet...${NC}\n"
        sleep 3
    done

    node node_modules/meshcentral/meshctrl.js --url wss://${meshdomain} --loginuser ${meshusername} --loginpass ${MESHPASSWD} AddDeviceGroup --name TacticalRMM
    sleep 1
}

# Configure and enable NATS service
enableNatsService()
{
    sudo systemctl enable nats.service
    cd /rmm/api/tacticalrmm
    source /rmm/api/env/bin/activate
    python manage.py initial_db_setup
    python manage.py reload_nats
    deactivate
    sudo systemctl start nats.service

    sleep 1
    sudo systemctl enable nats-api.service
    sudo systemctl start nats-api.service
}